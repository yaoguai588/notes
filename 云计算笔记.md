# Linux介绍

略

**（面试）内核与操作系统区别？**

内核是操作系统的核心部分，并负责该操作系统的所有主要活动。内核由各种模块组成，它直接与底层硬件交互。它还提供了所需的抽象，以将低级硬件详细信息隐藏到系统或应用程序中。没有内核，操作系统将无法运行，因为它是计算机系统工作的重要程序。

操作系统(OS)是管理计算机硬件资源并充当用户与计算机硬件之间的接口的软件集合。它为计算机程序提供通用服务。操作系统是计算机系统中系统软件的重要组成部分。

# 常用命令介绍

**初始化配置**

安装bash-completion

> [root@localhost ~]# yum install -y bash-completion 

安装vim工具

> [root@localhost ~]# yum install -y vim 

修改主机名

> [root@localhost ~]# hostnamectl set-hostname server1 

关闭防火墙开机自动启动

> [root@localhost ~]# systemctl disable firewalld 

**shell语法**

shell是系统的**用户界面** ,提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行。实际上shell是一个**命令解释器**，它解释用户输入的命令并且把用户的意图传达给内核。（可以理解为用户与内核之间的翻译官角色）

### cal命令

查看日历

- 选项

```bash
--help 所有命令都可以用这个来查看这个命令的所有选项
```

```bash
--year 长选项、单词拼全、两个--，表示显示一整年
```

```bash
-m 短选项、首字母，表示每个星期的星期一作为第一天
```

有些命令可不写选项，会有默认行为

短选项可多个合并，长选项不支持写一起

例如:-ym

- 参数

```bash
2020 是参数，参数是命令作用对象，表示查看2020日历
```

### ls命令

显示指定目录下内容 或 列出当前目录内容

- 选项

```bash
-a 显示所有文件及目录，.开头的隐藏文件也会被列出
-d 目录
-l 除文件名称外，也将文件形态、权限、拥有者、文件大小等信息详细列出 
	,即将文件详细信息以长格式形式展开，ls -l 可写成ll
// -l -a、-la可连用
-r 原来是以字母次序排序，让文件以相反次序显示
-t 将文件以建立时间逆序列出
-h 将显示出来的文件大小一合适的单位显示出来
-i 打印每一个文件的inode编号
```

> -A 同-a,但是不列出.（当前目录）和..（父目录）   脚本用的多
> -F 在列出的文件名称后加一符号，列如可执行文档加了*，目录加了/
> -R 若目录下有文件，则其下文件都依序列出

### cd命令

切换到当前目录

```bah
#跳转到指定目录
[root@localhost ~]# cd /usr/bin

#跳转到home目录
[root@localhost bin]# cd ~

#跳转到目录上一层
[root@localhost ~]# cd ..

#跳转到之前所在位置
[root@localhost /]# cd -
/root
[root@localhost ~]# cd -
/
```

### pwd命令

显示工作目录

```bash
#显示当前在哪，与pwd同
[root@localhost ~]# pwd -L
/root
[root@localhost ~]# pwd -P
/root
#可修改pwd变量，只是显示切换了路径，其实并没有
[root@localhost ~]# export PWD=/usr/bin
[root@localhost bin]#
#真正/usr/bin并非这样
```

### clear命令

清除屏幕内容

使用快捷键crtl+l也可以达到相同效果

### echo命令

用于字符串的输出

```bash
#输出
[root@localhost bin]# echo hello world
hello world

#输出
[root@localhost bin]# echo "hello world"
hello world

#-n不输出行尾的换行符
[root@localhost bin]# echo -n "hello world"
hello world[root@localhost bin]#

#-e \n换行符
[root@localhost bin]# echo  "hello\nworld"
hello\nworld
[root@localhost bin]# echo -e "hello\nworld"
hello
world

#-e \t水平制表符
[root@localhost bin]# echo -e "hello\tworld"
hello   world

#-e \a报警符
[root@localhost bin]# echo -e "hello\aworld"
helloworld

#-e \c禁止尾随的换行符
[root@localhost bin]# echo -e "hello\cworld"
hello[root@localhost bin]#

#-e \f换页符
[root@localhost bin]# echo -e "hello\fworld"
hello
     world

#-e \r回车符
[root@localhost bin]# echo -e "hello\rworld"
world

#-e \t水平制表符
[root@localhost bin]# echo -e "hello\tworld"
hello   world

#-e \v纵向制表符
[root@localhost bin]# echo -e "hello\vworld"
hello
     world

#清屏
[root@localhost bin]# echo -en "\f"

#-e \b退格符
[root@localhost bin]# echo -e "hello\b"
hello
[root@localhost bin]# echo -e "hello\bworld"
hellworld
```

-E 禁止对在STRINGs中的那些序列进行解释

# 系统命令

## poweroff 

用于关闭计算器并切断电源

选项

- -n：强制关机不保存，已保存则不变
- -w:非真正关机，只是告诉你关机行为，会记录到 /var/log/wtmp 档案里
- -d:不记录这次关机，不记录到 /var/log/wtmp 文件里
- i ：在关机前把所有网络相关的装置先停止
- -p:关闭前将系统中所有的硬件设置为备用模式

## reboot 

用于重启计算机

选项与poweroff几乎一样

## whoami 

用于显示自身用户名

```bash
[root@localhost bin]# whoami
root
```

# 快捷键

> Ctrl+

- C 终止前台运行的程序
- D 退出  等价exit
- L 清屏
- A 光标移动到命令行最前端
- E 光标移动到命令行最后端
- U 删除光标前所有字符
- K 删除光标后所有字符
- R 搜索历史命令，利用关键词

# 帮助命令

## history 查看最近敲过的一千条命令

选项

- -c 清空历史命令

  > history -c 清空所有history记录，但不清空~/.bash_history文件

- -a 追加本次会话命令历史列表至历史文件中

  > 将新增命令写入histfiles,默认写入~/.bash_history，一般在断开连接重启后才会写入，也可以用-a直接写入

- -d 删除历史指定的命令：history -d 数字

- -r 将history内容读入到目前shell的history记忆中

- -w 将目前history记忆的内容写入到histfiles

  > history -w histfiles.txt 将history内容写入到一个新文件中

  使用**！**执行历史命令

- **！number**执行第几条命令：！29

- **！ command**

  从最近的命令查到以**command**开头的命令执行：！ping

- **！！**执行上一条

- **!$** 引用上一条目录最后一个参数,当上一个命令没有参数的时候，!$代表的是上一个命令本身

## help 显示命令的帮助信息

ls --help

```bash
#查看help的帮助信息
[root@localhost bin]# help help
help: help [-dms] [模式 ...]
    显示内嵌命令的相关信息。

    显示内嵌命令的简略信息。如果指定了 PATTERN 模式，
    给出所有匹配 PATTERN 模式的命令的详细帮助，否则打
    印一个帮助主题列表

    选项：
      -d        输出每个主题的简短描述
      -m        以伪 man 手册的格式显示使用方法
      -s        为每一个匹配 PATTERN 模式的主题仅显示一个用法
        简介

    参数：
      PATTERN   Pattern 模式指定一个帮助主题

    退出状态：
    返回成功，除非 PATTERN 模式没有找到或者使用了无效选项。
#-d 输出每个主题的简短描述 -d 与 help不分先后
[root@localhost bin]# help -d help
help - Display information about builtin commands.
#-m 以伪man手册的格式显示使用方法
[root@localhost bin]# help -m help
NAME
    help - 显示内嵌命令的相关信息。

SYNOPSIS
    help [-dms] [模式 ...]

DESCRIPTION
    显示内嵌命令的相关信息。

    显示内嵌命令的简略信息。如果指定了 PATTERN 模式，
    给出所有匹配 PATTERN 模式的命令的详细帮助，否则打
    印一个帮助主题列表

    选项：
      -d        输出每个主题的简短描述
      -m        以伪 man 手册的格式显示使用方法
      -s        为每一个匹配 PATTERN 模式的主题仅显示一个用法
        简介

    参数：
      PATTERN   Pattern 模式指定一个帮助主题

    退出状态：
    返回成功，除非 PATTERN 模式没有找到或者使用了无效选项。

SEE ALSO
    bash(1)

IMPLEMENTATION
    GNU bash， 版本 4.2.46(2)-release (x86_64-redhat-linux-gnu)
    Copyright (C) 2011 Free Software Foundation, Inc.
    许可证 GPLv3+: GNU GPL 许可证版本3或者更高 <http://gnu.org/licenses/gpl.html>
#-s 为每一个匹配PATTERN模式的主题仅显示一个用法
[root@localhost bin]# help -s help
help: help [-dms] [模式 ...]
```

## man 显示在线帮助手册

man xxx

**快捷键**

空格键	向下翻一页

Pagedown	向下翻一页

Pageup	向上翻一页

home	直接前往首页

end	直接前往尾页

/	从上往下搜索某个关键词，如“/linux”

?	从下往上搜索某个关键词，如“?linux”

n	定位到下一个搜索到的关键词

N	定位到上一个搜索到的关键词

q	退出帮助文档

**手册结构**

NAME 命令名称

SYNOPSIS 参数的大致使用方法

DESCRIPTION 介绍说明

EXAMPLES 演示（附带简单说明）

OVERVIEW 概述

DEFAULTS 默认的功能

OPTIONS 具体的可用选项（有介绍）

ENVIRONMENT 环境变量

FILES 用到的文件

SEE ALSO 相关的资料

HISTORY 维护历史与联系方式

**中文man手册的安装**

yum -y install man-pages-zh-CN.noarch

(注意并不完整)

> yum -y install man-pages-zh-CN.noarch 
>
> echo "alias cman='man -M /usr/share/man/zh_CN'" >> .bashrc 
>
> source .bashrc 

![image-20220112150522319](C:\云计算笔记\云计算笔记.assets\image-20220112150522319.png)

**技巧1：按章节查询**

```bash
[root@xwz ~]# man -f passwd 
sslpasswd (1ssl) - compute password hashes 
passwd (1) - update user's authentication tokens 
[root@xwz ~]# man 1 passwd 
[root@xwz ~]# man 5 passwd
```

**技巧2：在所有章节中查询**

```bash
[root@xwz ~]# man -a passwd
```

## alias 命令别名

用于设置指令的别名（\别名 可跳过别名，一般别名优先）

```bash
[root@localhost bin]# alias
alias cp='cp -i'
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias ls='ls --color=auto'
alias mv='mv -i'
alias rm='rm -i'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'

[root@localhost bin]# ls -l
总用量 14460
-rw-------. 1 root root     1241 10月 30 12:09 anaconda-ks.cfg
drwxr-xr-x. 2 root root       22 11月  7 16:18 code
-rw-r--r--. 1 root root 14801905 6月   4 12:37 phpMyAdmin-5.1.1-all-languages.zip
[root@localhost bin]# ll
总用量 14460
-rw-------. 1 root root     1241 10月 30 12:09 anaconda-ks.cfg
drwxr-xr-x. 2 root root       22 11月  7 16:18 code
-rw-r--r--. 1 root root 14801905 6月   4 12:37 phpMyAdmin-5.1.1-all-languages.zip
```

为了让别名永久生效，可以修改别名的命令写入bashrc文件，这个文件中的命令会在每次登陆命令行的时候执行

```bash
alias wl='ip address'
wl
##写入
echo "alias wl='ip address'">>/etc/bashrc
```

或

``` bash
[root@xwz ~]# vi /etc/bashrc # 添加如下行 
alias wl='ip address'
```

# 文件管理

Windows：**多根**方式组织文件 C:/ D:/

Linux：**单根**方式组织文件 /

- **绝对路径**（任何时都可敲）

由根目录/写起，例如：/usr/share/doc

- **相对路径**（非常依赖当前所在目录）

不由/写起，由当前目录出发，例如：由/usr/share/doc要到/usr/share/man底下，可写成：cd ./man或者cd man(已在/usr/share下)

## 目录功能

![image-20220112145243023](C:\云计算笔记\云计算笔记.assets\image-20220112145243023.png)

**文件管理命令**

常见的几个文件管理命令

- ls 列出
- cd 切换
- pwd 显示
- mkdir 创建一个新目录
- rmdir 删除一个空目录
- cp 复制文件或目录
- rm 删除文件或目录
- mv 移动文件与目录 或者 修改文件与目录名称

## touch（创建新文件）

用于修改文件或目录的时间属性，包括存取时间和更改时间，

**若不存在则新建一个空白文件，若存在则修改该文件时间**。

touch --date=2022-01-01 文件名 #修改为指定日期

```bash
[root@localhost bin]# touch newfile
```

touch file{1..20}	连续创建20个

## mkdir(创建新目录)

- -m 配置文件权限
- -p 帮助用户之间将所需要目录（包含上一级目录）递归创建，即一次性创建好多级目录
- -v 显示目录创建过程

```bash
[root@localhost bin]# mkdir -pv a/b/c
mkdir: 已创建目录 "a"
mkdir: 已创建目录 "a/b"
mkdir: 已创建目录 "a/b/c"
```

创建时不知道有无此文件，可以加-p

## cp(复制文件或目录)

> SRC为单个文件：
>
> DEST不存在，将SRC文件内容写入DEST文件中
>
> DEST存在，将SRC文件覆盖DEST文件中
>
> 如果DEST是目录：创建新文件并写入内容
>
> 
>
> SRC为多个文件：
>
> DEST必须为目录
>
>  SRC为目录： 使用选项‐r
>
> DEST为目录：
>
> DEST不存在：创建同名目录和一致性文件
>
> DEST存在：一致性文件 DEST为文件：报错

**选项**

- -a 相当于 -pdr 的意思
- -d 复制后保持文件夹原样

若来源档为连接档（快捷方式）的属性，则复制连接档属性而非文件本身

- -f 强制，若目标文件已存在且无法开启，则移除后再尝试，即覆盖
- -i 若目标档已经存在，在覆盖时会询问动作的进行，默认带i（cp别名cp -i）,cp前带\则不提示
- -l 进行硬式连结的连接档创建，而非复制文件本身
- -p 连同文件所有属性一起复制过去，而非使用默认属性（备份常用）
- -r 递归持续复制，用于目录的复制行为（常用）
- -s 复制成为符号连接档，即 快捷方式
- -u 若目标档（destination）比source旧才升级destination
- -v 显示复制的详细过程

## mv(移动文件与目录，或修改名称)

移动文件与目录，或修改名称

**选项**

- -f 强制，如果文件已存在，不会询问直接覆盖
- -i 若目标文件已存在，会询问是否覆盖
- -u 若目标文件已存在，且source比较新，才会升级
- -v 显示复制的详细过程

## rm(删除文件或目录)

删除文件或目录

rm -rf  /*

**选项**

- -f 强制，忽略不存在的文件，不出现警告信息
- -i 互动模式，在删除前会询问使用者是否动作
- -r 递归删除，最常用在目录的删除上

# 文本查看

## cat

从文件头部开始查看文件，一次性加载全部内容

**选项**

- -n 由1开始对所有输出的行数编号
- -b 和-n相似，但是对空白行不编号
- -s 当遇到连续两行以上空白行，就代换为一行的空白行
- -A 显示控制符号

## tac

从文件尾部**逆序**开始查看全部文件，一次性加载全部内容

## less

**不会一次性加载**文件所有内容，可以通过空格或回车向后查询

## more

more和less类似，但是more**查看完便结束，不可回看**

## head

从文件头部开始查看内容，默认一次性显示十行内容

**选项**

- -q 隐藏文件名，默认是隐藏
- -v 显示文件名
- -c<数目> 显示字节数 -100 
- -n<行数> 显示的行数 默认时是十行  -20

## tail

从文件末尾开始查看 ，默认一次性显示十行内容

**选项**

- -f 动态监控内件内容，与tailf同，用于帮助查看实时日志
- -q 隐藏文件名，默认隐藏
- -v 显示文件名
- -c<数目> 显示字节数 -100 
- -n 可以指定显示行数，显示文件的尾部n行内容 默认十行，例： -20
- -s 与-f连用，表示在每次反复的间隔休眠S秒

## grep

针对文本内容进行过滤，本工具属于文本三剑客，后续会详细讲解

- grep 'root' 文件

#在文件中找出有root的行

- grep '^root' 文件

#在文件中找出root开头的行

- grep 'bash$' 文件

#在文件中找出bash结尾的行

# 文本文件编辑

目前常见的文本编辑器：

- nano 在debain系列系统常见
- vi 所有的Unix Like系统都会内建vi文本编辑器，其他的文本编辑器则不一定会存在
- vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的准确性，方便程序设计

目前主要使用vim，vim是从vi发展出来的一个文本编辑器。 

## 命令模式

- i 切换到输入模式
- x 删除当前光标所在行
- ： 切换到末行模式，在最底一行输入命令

## 输入模式

在命令模式下按下i进入输入模式

- Insert按键 切换光标为输入/替换模式，光标将变成竖线/下划线

> a 进入插入模式，光标停在选中字母后 
>
> i 进入插入模式，光标停在选中字母的位置 
>
> o 进入插入模式，光标停在选中一行的下面新建行中 
>
> A 进入插入模式，光标停在行尾 

## 末行模式

在命令模式下按 ：就会进入末行模式

> :10 进入第10行 
>
> :w 保存 
>
> :q 退出 
>
> :wq 保存并退出 
>
> :w! 强制保存 
>
> :wq! 强制保存退出 
>
> :x 保存并退出 ZZ 
>
> :X 加密文档 

## 可视化模式

> V 进入可视行模式 
>
> ^v 进入可视块模式 
>
> R 进入替换模式 

> 块插入 选择块，I 在块前插入字符，ESC 
>
> 块替换 选择块，r 输入替换的字符 
>
> 块删除 选择块， d|x 
>
> 块复制 选择块，y 

## 移动光标

- 上下左右

> h左   j下   k上   l右
>
> #command：跳转#个字符

- 单词跳转

> w：下个单词的词首 
>
> e：下个单词的词尾 
>
> b：上个单词的词首 
>
> #command：跳转#个单词 

- 行首行尾跳转

> ^：行首（非空白字符） 
>
> 0：行首 
>
> $：行尾 

- 行间移动

> \#G：跳转第N行 G 
>
> 1G：跳转第1行 gg 

- \+ 光标移动到非空格符的下一行
- \- 光标移动到非空格符的上一行
- n <space> n表示数字，按下数字再按下空格，光标会向右移动到这一行的第n个字符
- H 光标移动到这个屏幕的最上方那一行的第一个字符
- L 光标移动到这个屏幕的最下方那一行的第一个字符
- n<Enter> 向下移动n行 **常用**

## 文本编辑

- 删除文本

> d：删除，配合光标跳转 
>
> d^ 行首
>
> d$ 行尾
>
> d0 行首
>
> dw 下个单词的词首
>
> de 下个单词的词尾
>
> db 上个单词的词首
>
> dd：删除光标所在行 
>
> \#dd：删除多行 

- 复制文本：y，和删除的使用方式一样
- 粘贴命令：p
- 撤销命令

> u：撤销前一次 
>
> \#u：撤销前N次 

- 搜索命令

> 搜索操作： 
>
> :/ | ? 
>
> n：查找下一个匹配 
>
> N：跳转上一个匹配 

```bash
y 复制 yy 3yy ygg yG (以行为单位) 
d 剪切 dd 3dd dgg dG (以行为单位) 
p 粘贴 
x 删除光标所在的字符 
D 从光标处删除到行尾 
u undo撤销 
^r redo重做 
r 可以用来修改一个字符
```

## 查找替换

- /word 	向光标之下寻找一个名为Word的字符串 **常用**

- ？word   向光标之上寻找一个字符串名称为word的字符串

- n              这个n为英文按键，代表重复前一个搜寻的动作

- N             与n相反，为反向进行前一个搜寻动作

- ：n1,n2 s/word1/word2/g 

  n1与n2为数字，在第n1行与第n2行之间寻找word1这个字符串，并将字符串取代为word2,g表示全局 **常用**

- ：1，$s/word1/word2/g  或 %s/word1/word2/g

  $表示最后一行 ，%表示全文，从第一行到最后一行寻找word1字符串，并将该字符串取代为word2  **常用**

- 1，$s/word1/word2/gc 或 %s/word1/word2/gc 

  从第一行到最后一行寻找word1字符串，并将该字符串取代为word2,且在取代前显示提示字符给用户确认（confirm）是否需要取代 **常用**
  
- :,8 s/root/aaron/          从当前行到第8行 

- :4,9 s/^#//                     4-9行的开头#替换为空 

- :5,10 s/.\*/#&/               5-10前加入#字符(.*整行，&引用查找的内容) 

## **读写另存为**

> :w 存储到当前文件 
>
> :w /tmp/aaa.txt 	另存为/tmp/aaa.txt 
>
> :1,3 w /tmp/2.txt 	将1-3行保存到文件 
>
> :r /etc/hosts 			读入文件到当前行后 
>
> :5 r /etc/hosts 		读入文件到第5行后 

## 删除/剪切、复制与粘贴

- x,X   在一行字当中，x为向后删除一个字符（相当于del按键），X为向前删除一个字符（相当于backspace亦即是退格键） **常用**

-  nx 连续向后删除n个字符。 10x 连续删除10个字符

-  dd 删除/剪切光标所在的一整行 **常用**

- ndd 删除/剪切光标所在的向下n行

- d1G 删除光标所在到第一行的所有数据

- dG 删除光标所在到最后一行的所有数据

- d$ 删除光标所在处到该行的最后一个字符

- d0 数字0,删除光标所在处到该行的最前面一个字符

- yy 复制游标所在的那一行 **常用**

- nyy 复制光标所在的向下n行

- y1G 复制光标所在行到第一行的所有数据

- yG 复制光标所在行到最后一行的所有数据

- y0 复制光标所在的那个字符到该行行首的所有数据

- y$ 复制光标所在的那个字符到该行行尾的所有数据

- p,P   p为将已经复制的数据在光标下一行贴上，P则为贴在光标上一行 **常用**

  举例来说，目前光标在第20行，已经复制了20行数据，按下p后，那20行数据会粘贴在原来的20行之后，即从21开始粘贴；但如果按下P，那么原来的第20行会被推到后面的第40行

- J 将光标所在行与下一行的数据结合成同一行

- c 重复删除多个数据，例如10c 向下删除10行

- u 复原前一个动作 **常用**

- Ctrl + r 重做上一个动作 **常用**

- .    重复前一个动作 **常用**

## 进入输入或取代的编辑模式

- i,I    进入输入模式：i为从目前光标所在处输入，I为在目前所在行第一个非空格符处开始输入 **常用**
- a,A  进入输入模式：a为从目前光标所在的下一个字符处开始输入，A为光标所在行的最后一个字符处开始输入 **常用**
- o,O  进入输入模式：oWie在目前光标所在的下一处输入新的一行；O为在目前光标所在的上一行处输入新的一行 **常用**
- r,R   进入取代模式：r只会取代光标所在的那一个字符一次；R会一直取代光标所在处的文字，直到按下Esc为止 **常用**
- Esc 退出编辑模式，回到一般模式 **常用**

## 末行模式下的储存、离开等指令

- ：w 将编辑的数据写入硬盘中  **常用**
- ：w! 若文件属性为只读，强制写入该文件
- ：q 离开vi **常用**
- ：q! 若曾修改过文件，且不想储存，使用！为强制离开不储存
- ：wq 保存并退出，：wq! 则为强制储存后退出    **常用**
- ZZ 如果修改过文件则保存当前文件，然后退出，效果等同于保存并退出
- ：x 效果等同于保存并退出
- ：X 用于加密文件
- ZQ 不保存，强制退出，等同于：q!
- :w filename 将编辑的数据储存到另一个文件（类似文件另存为）
- ：r filename 在编辑的数据中，读入到另一个文件的数据，即将filename这个文件内容加到光标所在行后面
- ：n1,n2 w filename 将n1到n2的内容储存成filename这个文件
- ：！commend 暂时离开vi到bash命令行下执行commend的显示结果。例如：！ls/home 即可在vi当中查看/home底下ls输出的文件信息

## vim环境变量修改

> tab缩进,默认8
>
> ：ts=4 改为4
>
> 行号
>
> 显示：set number，简写为set nu 
>
> 取消显示：set nonumber，简写为set nonu 
>
> 括号匹配 
>
> 匹配：set showmatch，简写为set sm 
>
> 取消：set nosm 
>
> 自动缩进 
>
> 启用：set ai 
>
> 禁用：set noai 
>
> 高亮搜索 
>
> 启用：set hlsearch 
>
> 禁用：set nohlsearch 
>
> 语法高亮 
>
> 启用：syntax on 
>
> 禁用：syntax off 
>
> 忽略字符的大小写 
>
> 启用：set ic 
>
> 不忽略：set noic 
>
> 获取帮助 
>
> : help 

以上为临时环境设置,可以在用户的家目录下创建.vimrc文件，将vim环境变量写入，这样即可让当前用户每次试验vim时候可以显示行号

vim .vimrc

set number

**永久环境**

> /etc/vimrc 影响所有系统用户 
>
> ~/.vimrc 影响某一个用户 

## **多文件编辑**

```bash
[root@xwz ~]# vim -O ls.txt /etc/hosts	 ^ww切换
[root@xwz ~]# cp /etc/hosts hosts1 
[root@xwz ~]# vimdiff /etc/hosts hosts1
```

# 文件时间

## stat

(时间戳：1970年1月1日0点0分0秒到现在的秒数)

查看文件时间 建议改为英文系统环境

- Access 访问时间，也叫atime
  - 当文件被访问，此时间会改变
  - RHEL6开始relatime,atime延迟修改，必须满足其中一个条件：自上次atime修改后，已达到86400秒（一天24小时） 或 发生写操作时
- Modify 修改时间，也叫mtime
  - 当文件内容发生变化，此时间会改变
- Change 改变时间，也叫ctime
  - 当文件状态（属性、大小等）被改变的时候，此时间会改变

```bash
[root@server1 ~]# stat a
  文件："a"
  大小：15        	块：0          IO 块：4096   目录
设备：fd00h/64768d	Inode：33574989    硬链接：3
权限：(0755/drwxr-xr-x)  Uid：(    0/    root)   Gid：(    0/    root)
环境：unconfined_u:object_r:admin_home_t:s0
最近访问：2022-01-12 11:16:59.506155035 +0800
最近更改：2021-11-23 00:24:55.742091407 +0800
最近改动：2021-11-23 00:24:55.742091407 +0800
创建时间：-
```

# 文件类型

**通过颜色判断文件的类型是不一定正确的** **!!!!**

**Linux系统中文件是没有扩展名的!!!!**

## 方法一：ll

ls -l 文件名	//看第一个字符

- **-** 	普通文件(文本文档，二进制文件，压缩文件，电影，图片等)
- d    目录文件（蓝色）
- b    块设备文件（块设备）存储设备硬盘，U盘 /dev/sda,/dev/sda1 
- c     字符设备文件（字符设备）打印机，终端 /dev/tty1,/dev/zero 
- s     套接字文件
- p     管道文件
- l      链接文件（淡蓝色）

\-     普通文件

d    文件夹

```bash
[root@server1 ~]# ll -d /etc/hosts /bin/ls /home /dev/sda /dev/tty1 /etc/grub2.cfg /dev/log /run/dmeventd-client
# 第一行的第一个字母是标识文件的类型，文件类型一共有七类
-rwxr-xr-x. 1 root root 117680 10月 31 2018 /bin/ls
srw-rw-rw-. 1 root root      0 1月  12 11:07 /dev/log
brw-rw----. 1 root disk   8, 0 1月  12 11:07 /dev/sda
crw--w----. 1 root tty    4, 1 1月  12 18:51 /dev/tty1
lrwxrwxrwx. 1 root root     22 10月 30 12:07 /etc/grub2.cfg -> ../boot/grub2/grub.cfg
-rw-r--r--. 1 root root    158 6月   7 2013 /etc/hosts
drwxr-xr-x. 6 root root     60 11月 27 00:43 /home
prw-------. 1 root root      0 1月  12 11:07 /run/dmeventd-client
```

## 方法二：file

专门用来查看文件类型的命令

```bash
[root@localhost ~]# file file
file: empty
[root@localhost ~]# file /etc/hosts
/etc/hosts: ASCII text
```

## 方法三：stat

可以显示出文件的类型

```bash
[root@localhost ~]# stat /etc/hosts
  文件："/etc/hosts"
  大小：158             块：8          IO 块：4096   普通文件
设备：fd00h/64768d      Inode：17003084    硬链接：1
权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)
环境：system_u:object_r:net_conf_t:s0
最近访问：2021-11-23 22:06:41.621526216 +0800
最近更改：2013-06-07 22:31:32.000000000 +0800
最近改动：2021-10-30 12:06:43.957916335 +0800
创建时间：-
```

# 文件查找

find命令需熟练掌握，which和locate需要掌握

## which

用于查找文件,which指令在环境变量$PATH设置的目录里查找符合条件的文件

**环境变量**：一般是指在操作系统中用来指定操作系统运行环境的一些参数

```bash
[root@localhost ~]# which ls
alias ls='ls --color=auto'
        /usr/bin/ls
[root@localhost ~]# which ping
/usr/bin/ping
```

## locate

用于查找符合条件的文件，会去保存文件和目录名的数据库内查找合乎范本样式条件的文件或目录

**安装 yum -y install mlocate**

使用locate之前需要更新一下数据库，因为locate只会在数据库中查找文件所在位置，所以locate查找速度极快，缺点就是数据库更新不是实时，更新数据库有两种方式：

- 手动更新 输入 updatedb
- 默认情况 updatedb 会每天自动执行一次

```bash
[root@localhost ~]# yum -y install mlocate # 安装locate 
[root@localhost ~]# updatedb # 更新数据库 
[root@localhost ~]# locate hosts # 查找hosts文件名的文件 
[root@localhost ~]# locate /etc/sh # 查找/etc目录下所有以
```

**选项**

- -c 只输出找到的数量
- -n 至多显示n个输出
- -i 忽略大小写
- -r 使用基本正则表达式
- --regex 使用扩展正则表达式
- -d DBPATH 使用DBPATH指定的数据库而不是默认数据库

## find

实时查找工具，通过遍历指定路径下的文件系统完成文件查找

特点：

- 查找速度略慢
- 精确查找
- 实时查找
- 可满足多条件匹配

find 选项 路径 查找条件 + 处理动作

**查找条件**

- 根据文件名查找

```bash
[root@localhost ~]# find /etc -name "ifcfg-ens33"
/etc/sysconfig/network-scripts/ifcfg-ens33
[root@localhost ~]# find /etc -name "ifcfg-ens*"
/etc/sysconfig/network-scripts/ifcfg-ens33
/etc/sysconfig/network-scripts/ifcfg-ens33.bak
[root@localhost ~]# find /etc -name "ifcfg*"
/etc/sysconfig/network-scripts/ifcfg-lo
/etc/sysconfig/network-scripts/ifcfg-ens33
/etc/sysconfig/network-scripts/ifcfg-ens33.bak
```

- 根据文件大小

```bash
[root@localhost ~]# find /etc -size +5M	#大于5M
/etc/udev/hwdb.bin
[root@localhost ~]# find /etc -size 5M	#等于5M
[root@localhost ~]# find /etc -size -5M	#小于5M
[root@localhost ~]# find /etc -size +5M -ls	#找到的处理动作
17272988 7760 -r--r--r--   1 root     root      7942570 10月 30 12:12 /etc/udev/hwdb.bin
```

- 指定查找的目录深度

```bash
[root@localhost ~]# find / -maxdepth 3 -a -name "ifcfg-ens33"
#-a 同时，-o或
```

- 按照时间来查找

```bash
[root@localhost ~]# find /etc -mtime +5	#修改时间超过5天
[root@localhost ~]# find /etc -mtime 5	#等于5天
[root@localhost ~]# find /etc -mtime -5	#5天内
/etc
/etc/resolv.conf
/etc/tuned/active_profile
/etc/tuned/profile_mode
```

- 按照文件属主、属组找，文件的属主和属组下一节详解

```bash
[root@localhost ~]# find /home -user xwz	#属主xwz
find: 用户名 ‘xwz’ 未知
[root@localhost ~]# useradd xwz
[root@localhost ~]# find /home -user xwz
/home/xwz
/home/xwz/.bash_logout
/home/xwz/.bash_profile
/home/xwz/.bashrc
[root@localhost ~]# find /home -user xwz -group xwz
/home/xwz
/home/xwz/.bash_logout
/home/xwz/.bash_profile
/home/xwz/.bashrc
[root@localhost ~]# find /home -user xwz -a -group xwz
/home/xwz
/home/xwz/.bash_logout
/home/xwz/.bash_profile
/home/xwz/.bashrc
[root@localhost ~]# find /home -user xwz -o -group xwz
/home/xwz
/home/xwz/.bash_logout
/home/xwz/.bash_profile
/home/xwz/.bashrc
[root@localhost ~]# find /home -nouser	#没有属主
[root@localhost ~]# find /home -nogroup	#没有属组
```

```bash
[root@localhost ~]# userdel -r xwz
[root@localhost ~]# find /home -nouser	#没有属主
/home/xwz
/home/xwz/.bash_logout
/home/xwz/.bash_profile
/home/xwz/.bashrc
```

- 按文件类型

```bash
[root@localhost ~]# find /dev -type d
/dev
/dev/vfio
/dev/net
/dev/snd
/dev/snd/by-path
/dev/mqueue
/dev/hugepages
/dev/centos
/dev/disk
/dev/disk/by-label
/dev/disk/by-uuid
/dev/disk/by-path
/dev/disk/by-id
/dev/block
/dev/bsg
/dev/dri
/dev/char
/dev/mapper
/dev/pts
/dev/shm
/dev/input
/dev/input/by-path
/dev/input/by-id
/dev/bus
/dev/bus/usb
/dev/bus/usb/002
/dev/bus/usb/001
/dev/raw
/dev/cpu
/dev/cpu/0
```

- 按照文件权限

```bash
[root@localhost ~]# find / -perm 644 -ls
[root@localhost ~]# find / -perm -644 -ls
```

- 按照正则表达式

```bash
[root@localhost ~]# find /etc -regex ‘.ifcfg-ens[0-9][0-9]’
```

- 条件组合
  - -a 多个条件and并列
  - -o 多个条件or并列
  - -not 条件取反

## 处理动作

接在查找后面

- -print：默认的处理动作，显示至屏幕
- -ls 类型于对查找到的文件执行 ls -l 命令
- -delete 删除查找到的文件
- -fls/path/to/somefile 查找到的所有文件的长格式信息保存至指定文件中
- -ok COMMAND{} 对查找到的每个文件执行由COMMAND指定的命令，需要确认



查找当前系统上没有属主或属组，且最近一周内曾被访问过的文件或目录

```bash
[root@localhost ~]# find / \(-nouser -a -nogroup\) -a -atime -7
```

查找/etc目录下大于1M且类型为普通文件的所有文件或目录

```bash
[root@localhost ~]# find /etc -size +1M -type f
/etc/udev/hwdb.bin
/etc/selinux/targeted/active/policy.kern
/etc/selinux/targeted/contexts/files/file_contexts.bin
/etc/selinux/targeted/policy/policy.31
```

查找/etc目录下所有用户都没有写权限的文件

```bash
[root@localhost ~]# find /etc -not -perm /222
/etc/gshadow-
/etc/shadow-
/etc/gshadow
/etc/udev/hwdb.bin
/etc/lvm/profile/cache-mq.profile
/etc/lvm/profile/cache-smq.profile
/etc/lvm/profile/command_profile_template.profile
/etc/lvm/profile/lvmdbusd.profile
/etc/lvm/profile/metadata_profile_template.profile
/etc/lvm/profile/thin-generic.profile
/etc/lvm/profile/thin-performance.profile
/etc/machine-id
/etc/shadow
/etc/pki/ca-trust/extracted/java/cacerts
/etc/pki/ca-trust/extracted/openssl/ca-bundle.trust.crt
/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
/etc/pki/ca-trust/extracted/pem/email-ca-bundle.pem
/etc/pki/ca-trust/extracted/pem/objsign-ca-bundle.pem
/etc/ld.so.conf.d/kernel-3.10.0-957.el7.x86_64.conf
/etc/openldap/certs/password
/etc/sudoers
```

查找/etc目录下至少一类用户没有执行权限

```bash
[root@localhost ~]# find /etc -not -perm -111
```

# 管道以及重定向

## 重定向

- 程序 = 指令+数据
  - 数据（input/output）
  - 每打开一个文件都有一个文件描述符fd

- 输入输出
  - 标准输入
  - 标准正确输出 1
  - 标准错误输出 2

- 输出重定向：

  - \> ：正确覆盖重定向

  - \>> ：正确追加重定向

  - 2> ：错误覆盖重定向

  - 2>>：错误追加重定向

- 标准输出和错误输出各自重定向至不同位置

```bash
command 1> /path/file.out 2> /path/error.out /dev/null：垃圾桶
```

- **合并**标准输出和错误输出为同一个数据流进行重定向
  - &> :    覆盖重定向
  - &>>：追加重定向
  - 2>&1：将错误流重定向到标准输出文件中(>>)
  - 1>&2：将正确流重定向到标准错误输出文件中(>>)

```bash
[root@server1 ~]# cat /root/a/b/file1
ROOT:X:0:0:ROOT:/ROOT:/BIN/BASH
BIN:X:1:1:BIN:/BIN:/SBIN/NOLOGIN
DAEMON:X:2:2:DAEMON:/SBIN:/SBIN/NOLOGIN
ADM:X:3:4:ADM:/VAR/ADM:/SBIN/NOLOGIN
LP:X:4:7:LP:/VAR/SPOOL/LPD:/SBIN/NOLOGIN
ROOT     PTS/2        2022-01-12 10:28 (192.168.225.1)
[root@server1 ~]# echoo 'fdsf' &> /root/a/b/file1
[root@server1 ~]# cat /root/a/b/file1
-bash: echoo: 未找到命令
```

- 标准输入重定向

```bash
覆盖：
cat > /path/to/somefile <<EOF 
.... 
EOF 

追加： 
cat >> /path/to/somefile <<EOF 
.... 
EOF

[root@server1 ~]# cat > /root/a/file <<EOF
> 1
> 2
> 3
> EOF
[root@server1 ~]# cat /root/a/file
1
2
3
[root@server1 ~]# cat >> /root/a/file <<EOF
> 4
> 5
> 6
> EOF
[root@server1 ~]# cat /root/a/file
1
2
3
4
5
6
```

## 管道

- command1 | command2 | command3

- Note：最后一个命令会在当前shell进程的子shell进程中执行

## **小工具**

### **tr命令**

```bash
tr [option] [set1] [set2] 
常用选项： 
-d：删除 

案例1： 
将/etc/passwd文件中的前5行内容转换为大写后保存
至/tmp/passwd.out文件中 
[root@node1 ~]# head -n 5 /etc/passwd | tr 'a-
z' 'A-Z' > /tmp/passwd.output 

案例2： 将登陆至当前系统上用户信息中的最后1行的信息转换
为大写后保存至/tmp/who.out文件中 
[root@node1 ~]# who | tail -n 1 | tr 'a-z' 'A-
Z' >/tmp/who.out

例：
[root@server1 ~]# who
root     tty1         2022-01-12 10:11
root     pts/0        2022-01-12 10:22 (192.168.225.1)
root     pts/1        2022-01-12 10:25 (192.168.225.1)
root     pts/2        2022-01-12 10:28 (192.168.225.1)
[root@server1 ~]# who | tail -n 1 | tr 'a-z' 'A-Z' >>/root/a/b/file1
[root@server1 ~]# cat /root/a/b/file1
ROOT     PTS/2        2022-01-12 10:28 (192.168.225.1)
```

### **wc命令**

> 常用选项： 
>
> -l：行数 
>
> -w：单词数 
>
> -c：字符数 

```bash
[root@server1 b]# cat > /root/a/b/file1 <<EOF
> 1
> 2
> 3
> 4
> 5
> 
> 4
> 5
> 
> 
> 3434
> 34434
> 
> 434
> 345EOF
> EOF
[root@server1 b]# wc -l file1
15 file1
[root@server1 b]# wc -w file1
11 file1
[root@server1 b]# wc -c file1
40 file1
```

### **cut命令**

> 常用选项： 
>
> -d：指定分隔符 
>
> -f：指定字段 

### **sort命令**

> 常用选项： 
>
> -f：忽略大小写 
>
> -r：逆序 
>
> -t：字段分隔符 
>
> -k #：以指定字段为标准排序 
>
> -n：以数值进行排序 
>
> -u：排序后去重 

### uniq命令

```bash
常用选项： 
-c：显示每行重复出现的次数 
-d：仅显示重复过的行 
-u：仅显示不曾重复的行 

案例1： 以:为分割，取出/etc/passwd文件的第6列至第10列，并将这些信息按照第3个字段的数值大小进行排序，最后仅 显示一个字段 
[root@node1 ~]# cut -d: -f6-10 /etc/passwd 
|cut -f3 | sort -n |uniq -c
```

# 用户/组基本概念

用户和组

- 系统上的每个进程(运行的程序)都是作为特定用户运行

- 每个文件是由一个特定的用户拥有

- 访问文件和目录受到用户的限制

- 与正在运行的进程相关联的用户确定该进程可访问的文件和目录



查看当前登录的用户信息

```bash
[root@server1 b]# id
uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[root@server1 b]# id xiao
uid=6667(xiao) gid=6667(xiao) 组=6667(xiao)
```

查看文件owner

```bash
[root@server1 b]# ll /home
总用量 0
drwx------. 2   1000   4001 62 11月 27 00:07 itadmin
drwx------. 2 user01 user01 83 11月 27 00:36 user01
drwx------. 2 user02 user02 62 11月 27 00:20 user02
drwx------. 2 xiao   xiao   62 1月  12 16:49 xiao
drwx------. 2   1000 hr     62 11月 26 22:43 xwz
```

和用户组相关的一些文件

>/etc/passwd
>存放用户信息的文件
>root:
>
>x:0:0:root:/root:/bin/bash
>	用户名
>	密码占位符
>	uid
>		uid为0的用户为root用户
>		centos7中uid在1-999的用户为系统用户
>		centos7中uid1000+的用户为普通用户
>	gid
>		组id，概念和uid类似
>	描述信息
>	用户的家目录
>	用户的登陆shell
>
>/etc/shadow
>存放用户密码信息的文件
>
>/etc/group
>存放组信息的文件

```bash
/etc/passwd 
root:x:0:0:root:/root:/bin/bash 
# 用户名:x:uid:gid:描述:HOME:shell  x密码占位符 
/etc/shadow 
root:$6$j3YZCHCXpIiDho7x$v4/j6b0zGgyTcfP6jOa1ZY.q.sHvqQp/nsmEowjrtmo/iFKdo4X piWZm5OpDKqhZEw8OSXTpdAM2JyIgBI.Mz0::0:99999:7::: $id$salt$encrypted 
# 密码信息 
/etc/group 
root:x:0: # 组的信息 

# man 5 passwd 
# man 5 shadow 
# man 5 group 
# man 3 crypt
```

加密算法$id

> $1 MD5 
>
> $5 SHA-256 
>
> $6 SHA-512 

系统约定

> uid:0 特权用户 
>
> uid:1~999 系统用户 
>
> uid:1000+ 普通用户 

root用户

> uid是0
>
> 所有权力
>
> 该用户有权力覆盖文件系统上的普通权限
>
> 安装或删除软件并管理系统文件和目录
>
> 大多数设备只能由root控制

## **用户管理**

groupadd	groupdel

useradd	usermod	userdel

passwd	chage

### **用户组**

```bash
[root@xwz ~]# groupadd hr 
[root@xwz ~]# groupadd sale 
[root@xwz ~]# groupadd it 
[root@xwz ~]# groupadd fd 
[root@xwz ~]# groupadd market 
[root@xwz ~]# groupadd net01 -g 2000 
[root@xwz ~]# grep 'net01' /etc/group net01:x:2000: 
net01:x:2000:
[root@xwz ~]# groupdel net01
```

### 用户

- 添加用户	

useradd常用参数

> 常用选项： 
>
> -u：指定uid 
>
> -g：指定gid 
>
> -c：用户注释信息 
>
> -d：家目录 
>
> -s：指定shell（/etc/shells） 
>
> -G：附加组 
>
> -r：创建系统用户 

```bash
[root@server1 ~]# useradd user01
# 未指定该用户的主组 
# 未指定该用户的附加组 
# 未指定用户的HOME 
# 未指定用户的SHELL 
# 未指定用户的UID...
[root@server1 ~]# grep 'user01' /etc/passwd /etc/shadow /etc/group
/etc/passwd:user01:x:1001:1001::/home/user01:/bin/bash
/etc/shadow:user01:!!:18957:0:99999:7:::
/etc/group:user01:x:1001:
[root@server1 ~]# id user01
uid=1001(user01) gid=1001(user01) 组=1001(user01)
[root@server1 ~]# ls /var/spool/mail/user01
/var/spool/mail/user01
[root@server1 ~]# ls /home
itadmin  user01  user02  xiao  xwz
```

如果创建一个用户时，未指定任何选项，系统会创建一个和用户名相同的组作为用户的 Primary Group 

```bash
[root@server1 ~]# useradd u02 -u 503  
# 创建用户user02,指定 uid
[root@server1 ~]# useradd u03 -d /u033
# 创建用户user03,指定家目录
[root@server1 ~]# useradd u04 -s /sbin/nologin
# 创建用户并指定shell
[root@server1 ~]# useradd u05 -G hr,it,fd
# 创建用户，指定附加组
[root@server1 ~]# useradd u06 -u 4000 -s /sbin/nologin
```

![image-20220113152312998](C:\云计算笔记\云计算笔记.assets\image-20220113152312998.png)

注意：

- -g -G 仅适用useradd创建用户时使用

- -g -G 指定的组必须事先存在



- 删除

```bash
[root@server1 ~]# userdel user01 # 删除用户user01，但是不删除用户的home和mail
[root@server1 ~]# ll -d /home/user01
drwx------. 2 1001 1001 83 11月 27 00:36 /home/user01
[root@server1 ~]# ll /var/spool/mail/user01
-rw-rw----. 1 1001 mail 0 11月 27 00:18 /var/spool/mail/user01

[root@server1 ~]# userdel -r user02 # 删除用户user02,并且同时删除用户的home和mail
```

- 修改用户密码

> 两种改密码的方式
> 	passwd 用户名
> 	echo "password" | passwd --stdin 用户名

```bash
[root@server1 ~]# passwd u02
更改用户 u02 的密码 。
新的 密码：
无效的密码： 密码是一个回文 #1
重新输入新的 密码： #12
passwd：所有的身份验证令牌已经成功更新。
# root用户可以直接设置普通用户密码 
# 普通用户必须要提供原密码，才可以修改自己密码
```

> 常用选项： 
>
> -n mindays：指定最短使用期限 
>
> -x maxdays：最大使用期限 
>
> -w warndays：提前多少天开始警告 
>
> -i inactivedays：非活动期限 
>
> --stdin：从标准输入接收用户密码 
>
> echo "PASSWD" | passwd --stdin username

- 修改用户组

```bash
[root@xwz ~]# usermod -G hr user05 # 覆盖原有的附加组 
[root@xwz ~]# usermod -G fd,it user05 
[root@xwz ~]# usermod -aG sale user05 # 增加新的附加组
```

```bash
[root@xwz ~]# grep 'user03' /etc/group 
user03:x:1008: 
[root@xwz ~]# gpasswd -a user03 hr 
正在将用户“user03”加入到“hr”组中 
[root@xwz ~]# grep 'user03' /etc/group 
hr:x:1001:user03 
user03:x:1008:
```

```bash
[root@xwz ~]# gpasswd -M user03,user04 fd 
[root@xwz ~]# id user03 
uid=1002(user03) gid=1008(user03) 组=1008(user03),1001(hr),1004(fd) 
[root@xwz ~]# id user04 
uid=1003(user04) gid=1009(user04) 组=1009(user04),1004(fd)
```

```bash
[root@xwz ~]# gpasswd -d user03 hr 
正在将用户“user03”从“hr”组中删除 
[root@xwz ~]# id user03 
uid=1002(user03) gid=1008(user03) 组=1008(user03),1004(fd)
```

```bash
[root@xwz ~]# usermod -s /sbin/nologin user03 
# 修改用户的shell
```

- 用户删除

```bash
userdel -r：连同家目录一起删除
```

## no shell

shell 是用户登录后运行的第一个程序

/sbin/nologin 		用户无法登录系统，实现管理。仅作为运行进程的用户，访问FTP的用户。安全的用户

/bin/bash 				登录系统，实现管理

图形化登录

命令行登录

切换用户

如果设置为/usr/sbin/poweroff，那么一登录就会关机(setenforce 0)

```bash
[root@server1 ~]# grep 'bash$' /etc/passwd   #查看允许登录的所有用户
root:x:0:0:root:/root:/bin/bash
xiao:x:6667:6667::/home/xiao:/bin/bash
u02:x:503:6670::/home/u02:/bin/bash
u03:x:6668:6671::/u033:/bin/bash
u05:x:6670:6673::/home/u05:/bin/bash
```

## **login.defs**

useradd参照文件

创建用户时对用户的一些限制，对root用户无效

```bash
[root@xwz ~]# vim /etc/login.defs 
MAIL_DIR 		/var/spool/mail 
PASS_MAX_DAYS 	99999 
PASS_MIN_DAYS 	0 
PASS_MIN_LEN 	5 
PASS_WARN_AGE 	7 
CREATE_HOME 	yes 
ENCRYPT_METHOD SHA512 
[root@xwz ~]# vim /etc/default/useradd 
SHELL=/bin/bash
[root@xwz ~]# chage -m 0 -M 90 -W 7 -I 14 user01 
[root@xwz ~]# chage -h
[root@xwz ~]# useradd user01 
[root@xwz ~]# echo 123456 |passwd --stdin user01 
更改用户 user01 的密码 。 
passwd：所有的身份验证令牌已经成功更新。 
[root@xwz ~]# chage -d 0 user01 # 强制用户在下次登录的时候换密码
```

> 用法：chage [选项] 登录 
>
> 选项：
>
> -d, --lastday 最近日期 将最近一次密码设置时间设为“最近日期” 
>
> -E, --expiredate 过期日期 将帐户过期时间设为“过期日期” 
>
> -h, --help 显示此帮助信息并推出 
>
> -I, --inactive INACITVE 过期 INACTIVE 天数后，设定密码为失效状态 
>
> -l, --list 显示帐户年龄信息 
>
> -m, --mindays 最小天数 将两次改变密码之间相距的最小天数设为“最小天数” 
>
> -M, --maxdays 最大天数 将两次改变密码之间相距的最大天数设为“最大天数” 
>
> -R, --root CHROOT_DIR chroot 到的目录 
>
> -W, --warndays 警告天数 将过期警告天数设为“警告天数” 

新建用户 home 目录下的 bash 开头的文件是从 /etc/skel/ 中复制过去的

## sudo提权

[Linux 命令 su 和 sudo 的区别？ (qq.com)](https://mp.weixin.qq.com/s?__biz=MzI4MDEwNzAzNg==&mid=2649455207&idx=1&sn=5401504ad2182cd889b0c4552ae84b59&chksm=f3a25b14c4d5d2027de2b16c0d3d6625eb1bf31adafca11a4f6408921b53f1a8860bb0bccc00&mpshare=1&scene=24&srcid=1124CetYD6pz96KzfNB1cHgY&sharer_sharetime=1637718112003&sharer_shareid=905157c7c855bab1d309ddf4053c8148&ascene=14&devicetype=android-29&version=2800105d&nettype=cmnet&abtest_cookie=AAACAA%3D%3D&lang=zh_CN&exportkey=A0jexOqWJmQCu9UzOtSD3J8%3D&pass_ticket=2OkP8VZpsuLPZuexsqx4bSYqFETvWvDvdq%2F74%2BXt0%2Bm%2BBAJ%2BQAl9N9%2FndWjmSXKD&wx_header=3)

通常普通的权限比较低，如果想要给普通root权限的话需要进行sudo提权，sudo提权的思路是将普通用户加入到wheel组中即可

操作 ：usermod -aG wheel 用户名

```bash
[root@server1 ~]# su - u02
上一次登录：三 1月 12 21:26:11 CST 2022pts/0 上
[u02@server1 ~]$ useradd u00
-bash: /usr/sbin/useradd: 权限不够
[u02@server1 ~]$ su - root
密码：
上一次登录：三 1月 12 21:31:36 CST 2022pts/0 上
[root@server1 ~]# usermod -aG wheel u02 #加入wheel组
[root@server1 ~]# id u 02
id: 额外的操作数 "02"
Try 'id --help' for more information.
[root@server1 ~]# id u02
uid=503(u02) gid=6670(u02) 组=6670(u02),10(wheel)
[root@server1 ~]# su - u02
上一次登录：三 1月 12 21:31:56 CST 2022pts/0 上
[u02@server1 ~]$ useradd u00
-bash: /usr/sbin/useradd: 权限不够
[u02@server1 ~]$ sudo useradd u00
[sudo] u02 的密码：
[u02@server1 ~]$ id u00
uid=6671(u00) gid=6675(u00) 组=6675(u00)
```

# 基本权限 UGO

文件权限设置：可以赋予某个用户或组，能够以何种方式，访问某个文件

![image-20220113145304731](C:\云计算笔记\云计算笔记.assets\image-20220113145304731.png)

## *UGO设置基本权限(r、w、x)*

权限对象：

> 属主：u
>
> 属组：g
>
> 其他人：o

权限类型:

> 读：r 4
>
> 写：w 2
>
> 执行：x 1
>
> 
>
> rwx 7
>
> rw- 6
>
> r-- 4
>
> 764
>
> rwxrw-r--

## 权限管理

更改文件的属主、属组

```bash
[root@xwz ~]# chown centos:hr file1 # 改属主、属组 
[root@xwz ~]# chown centos file1 # 只改属主 
[root@xwz ~]# chown :hr file1 # 只改属组

[root@xwz ~]# chgrp it file1 # 改文件属性组 
[root@xwz ~]# chgrp -R it dir1 # 改文件属性组
```

- 更改文件权限

**使用符号更改**

​                    对象              赋值符            权限类型

​                      u                       +                       r

chmod          g                      -                        w           file1

​                      o                       =                       x 

​                      a

```bash
[root@xwz ~]# chmod u+x file1 # 属主增加执行 
[root@xwz ~]# chmod a=rwx file1 # 所有人等于读写执行 
[root@xwz ~]# chmod a=- file1 # 所有人没有权限 
[root@xwz ~]# chmod ug=rw,o=r file1 # 属主属组等于读写，其他人只读 
[root@xwz ~]# ll file1 # 显示结果
```

**使用数字**

```bash
[root@xwz ~]# chmod 644 file1 
[root@xwz ~]# ll file1
```

chown 改变某个文件的属主

chmod 改变某个文件的访问模式

- r、w、x权限对文件和目录的意义

![image-20220113194412465](C:\云计算笔记\云计算笔记.assets\image-20220113194412465.png)

```bash
#对目录有w权限
[root@xwz ~]# mkdir /dir10 
[root@xwz ~]# touch /dir10/file1 
[root@xwz ~]# chmod 777 /dir10/file1 
[root@xwz ~]# ll -d /dir10/ 
drwxr-xr-x. 2 root root 19 9月 4 11:44 /dir10/ 
[root@xwz ~]# ll /dir10/file1 
-rwxrwxrwx. 1 root root 0 9月 4 11:44 /dir10/file1 
[root@xwz ~]# su centos 
[centos@xwz root]$ cat /dir10/file1 
[centos@xwz root]$ rm -rf /dir10/file1 
rm: 无法删除"/dir10/file1": 权限不够

#对目录无w权限
[root@xwz ~]# chmod 777 /dir10/ 
[root@xwz ~]# chmod 000 /dir10/file1 
[root@xwz ~]# ll -d /dir10/ 
drwxrwxrwx. 2 root root 19 9月 4 11:44 /dir10/ 
[root@xwz ~]# ll /dir10/file1 
----------. 1 root root 0 9月 4 11:44 /dir10/file1 
[root@xwz ~]# su centos 
[centos@xwz root]$ cat /dir10/file1 
cat: /dir10/file1: 权限不够 
[centos@xwz root]$ rm -rf /dir10/file1
```

对目录有w权限，可以在目录中创建新文件，可以删除文件夹中的文件(跟文件权限无关)

对文件x权限小心给予

# **ACL设置基本权限(r,w,x)**

UGO设置基本权限：只能一个用户，一个组和其他人

ACL设置基本权限：r、w、x

> setfacl 
>
> 常用选项： 
>
> -m ：添加acl设定参数 
>
> -x ：删除acl设定参数 
>
> -b ：移除所有的ACL设定参数 
>
> -R ：递归添加acl设定参数 
>
> -d ：添加默认acl设定参数（目录） 
>
> 删除用户权限：setacl -x u:username filename 
>
> 删除组权限：setacl -x g:groupname filename 
>
> 删除整个acl权限：setacl -b filename 

设置

```bash
[root@xwz ~]# ll file1 -rw-r--r--. 1 centos it 0 9月 4 11:03 file1 
[root@xwz ~]# getfacl file1 
# file: file1 
# owner: centos 
# group: it 
user::rw- 
group::r-- 
other::r-- 
[root@xwz ~]# setfacl -m u:centos:rw file1 # 增加用户权限 
[root@xwz ~]# setfacl -m u:user05:- file1 # 增加用户权限 
[root@xwz ~]# setfacl -m o::rw file1 # 修改其他人权限
```

查看/删除

```bash
[root@xwz ~]# ll file1
-rw-rw-rw-+ 1 centos it 0 9月 4 11:03 file1 
[root@xwz ~]# getfacl file1 
# file: file1 
# owner: centos 
# group: it 
user::rw- 
user:centos:rw- 
user:user05:--- 
group::r-- 
mask::rw- 
other::rw- 
[root@xwz ~]# setfacl -m g:hr:r file1 # 增加组权限 
[root@xwz ~]# setfacl -x g:hr file1 # 删除组权限 
[root@xwz ~]# setfacl -b file1 # 删除所有acl权限

[root@xwz ~]# man setfacl 
[root@xwz ~]# getfacl file1 |setfacl --set-file=- file2 # 复制file1的acl给 file2
```

## **mask**

用于临时降低用户或组(除属主和其他人)的权限

mask决定了他们的最高权限

建议：为了方便管理文件权限，其他人的权限置为空

```bash
[root@xwz ~]# setfacl -m o::- file1 
[root@xwz ~]# setfacl -m m::--- file1 
[root@xwz ~]# getfacl file1 
# file: file1 
# owner: centos 
# group: it 
user::rw- 
group::r-- 						#effective:--- 
mask::--- 
other::--- 
```

## **default**

一般针对目录，默认权限独立于该目录本身的权限，规定了在该目录中创建的文件的默认ACL权限。

default可以指定在目录中创建出的新文件的acl权限

要求：希望centos能够对 /home 以及以后在 /home 下新建的文件有读、写、执行权限

```bash
[root@xwz ~]# setfacl -m u:centos:rwx /home 
[root@xwz ~]# setfacl -m d:u:centos:rwx /home 
[root@xwz ~]# getfacl /home getfacl: Removing leading '/' from absolute path names 
# file: home 
# owner: root 
# group: root 
user::rwx 
user:centos:rwx
group::r-x
mask::rwx 
other::r-x 
default:user::rwx 
default:user:centos:rwx 
default:group::r-x 
default:mask::rwx 
default:other::r-x
```

## **特殊权限**

文件的特殊权限包括：SUID 4、SGID 2、SBIT 1

suid：借出程序所有者的权限

s：程序所属主有x权限

S：程序所属主没有x权限

SUID权限仅对二进制程序有效

仅在本程序中拥有改权限

属主拥有s权限，即可将自己的权限暂时借给其他人使用

```bash
[root@server1 ~]# ll /root/file
-rw-r--r--. 1 root root 0 1月  12 12:04 /root/file
[root@server1 ~]# su - u02
上一次登录：三 1月 12 21:33:25 CST 2022pts/0 上
[u02@server1 ~]$ ll /root/file
ls: 无法访问/root/file: 权限不够
```

系统会检查进程的所有者，根据所有者设置的权限来确定是否对文件有权限

```bash
[root@server1 ~]# ll /etc/shadow
----------. 1 root root 954 1月  12 21:34 /etc/shadow
# 普通用户依旧是可以修改密码
[root@server1 ~]# ll /usr/bin/passwd
-rwsr-xr-x. 1 root root 27832 6月  10 2014 /usr/bin/passwd
```

二进制程序有效

执行者拥有x权限

执行过程中暂时拥有用户组权限

高级权限的类型

s：程序所属主有x权限

S：程序所属主没有x权限



**SBIT**权限：用来做共享目录

当属主拥有x权限时，用小写的字母t表示，当属主没有x权限时，用大写字母T权限表示1

只针对目录有效

**用户在此目录中创建文件时，只有root用户和自己可以删除该文件，其他用户是不可以修改此文件**

典型例子/tmp这个目录

[zhangsan@localhost tmp]$ ll -d /tmp/

drwxrwxrwt. 9 root root 4096 9月 13 16:08 /tmp/

suid 		4 			# 使用文件所有者身份执行文件<针对文件>

sgid 		2			 # 新建文件继承目录属组<针对目录>

sticky 	 1 			# 文件只能由文件拥有者，root,文件夹拥有者删除<针对目录>

## 设置或者修改特殊权限

> chmod u+s file 
>
> chmod g+s dir 
>
> chmod o+t dir 
>
> chmod 4777 file 
>
> chmod 7777 file 
>
> chmod 2770 dir 
>
> chmod 3770 dir

/tmp 文件夹是1777权限，否则会导致程序不能正常运行

大写的高级权限为表示普通权限没有 x

小写的高级权限为表示普通权限有 x

## chatter

```bash
[root@xwz ~]# lsattr file2 
---------------- file2 
[root@xwz ~]# chattr +a file2 
[root@xwz ~]# lsattr file2 
-----a---------- file2 
[root@xwz ~]# man chattr 
---------- 
ATTRIBUTES(属性) 
		当修改设置了'A'属性的文件时,它的atime记录不会改变. 这可以在笔记本电脑系统中避免某些磁盘I/O处理. 
		
		设置了`a'属性的文件只能在添加模式下打开用于写入. 只有超级用户可以设置或清除该属性. 
		
		设置了`c'属性的文件在磁盘上由内核自动进行压缩处理. 从该文件读取时返回的是未压缩的数据. 对该文件的一次写入会在保存它们到磁盘之前进行数据压缩. 
		
		设置了`d'属性的文件不能对其运行 dump(8) 程序进行备份. 
		
		设置了`i'属性的文件不能进行修改:你既不能删除它, 也不能给它重新命名,你不能对该文件创建链接, 而且也不能对该文件写入任何数据
		
		只有超级用户可以设置或清除该属性. 
		
		当删除设置了`s'属性的文件时,将对其数据块清零 并写回到磁盘上. 
		
		当修改设置了`S'属性的文件时, 修改会同步写入到磁盘上; 这与应用 到文件子系统上的`sync'挂载选项有相同的效果. 
		
		当删除设置了`u'属性的文件时, 将会保存其内容. 这使得用户可以请求恢复被删除的文件. 
----------------
```

## **进程umask**

进程  新建文件、目录的默认权限会收到umask的影响，umask表示要减掉得到权限

shell (vim,touch) 		新文件或目录权限

vsftpd 						 新文件或目录权限

samba 						新文件或目录权限

useradd 						用户HOME

```bash
[root@server1 ~]# type -a umask
umask 是 shell 内嵌
umask 是 /bin/umask
umask 是 /usr/bin/umask
[root@server1 ~]# help umask
umask: umask [-p] [-S] [模式]
    显示或设定文件模式掩码。
    
    设定用户文件创建掩码为 MODE 模式。如果省略了 MODE，则
    打印当前掩码的值。
    
    如果MODE 模式以数字开头，则被当作八进制数解析；否则是一个
    chmod(1) 可接收的符号模式串。
    
    选项：
      -p	如果省略 MDOE 模式，以可重用为输入的格式输入
      -S	以符号形式输出，否则以八进制数格式输出
    
    退出状态：
    返回成功，除非使用了无效的 MODE 模式或者选项。
```

示例1:在shell进程中创建文件

```bash
[root@server1 ~]# umask
0022
[root@server1 ~]# umask -S
u=rwx,g=rx,o=rx
[root@server1 ~]# umask -s
-bash: umask: -s: 无效选项
umask: 用法:umask [-p] [-S] [模式]
[root@server1 ~]# touch file1
[root@server1 ~]# mkdir dir1
[root@server1 ~]# ll -d dir1/file1
ls: 无法访问dir1/file1: 没有那个文件或目录
[root@server1 ~]# ll -d dir1/ file1
drwxr-xr-x. 2 root root 6 1月  12 22:21 dir1/
-rw-r--r--. 1 root root 0 1月  12 22:21 file1
```

示例2:修改shell umask值(临时)

```bash
[root@server1 ~]# umask 0000
[root@server1 ~]# mkdir dir2
[root@server1 ~]# touch file2
[root@server1 ~]# ll -d file2 dir2
drwxrwxrwx. 2 root root 6 1月  12 22:23 dir2
-rw-rw-rw-. 1 root root 0 1月  12 22:23 file2
```

示例3:修改shell umask值(永久 建议别改)

```bash
[root@xwz ~]# vim /etc/profile 
-------------- 
59 if [ $UID -gt 199 ] && [ "`/usr/bin/id -gn`" = "`/usr/bin/id -un`" ]; then 
60 umask 002 
61 else 
62 umask 022 
63 fi 
--------------- 
[root@xwz ~]# source /etc/profile # 立即在当前shell中生效
```

示例4:通过umask决定新建用户 HOME 目录的权限

```bash
[root@xwz ~]# vim /etc/login.defs 
----------------- 
61 # The permission mask is initialized to this value. If not specified, 
62 # the permission mask will be initialized to 022. 
63 UMASK 077 
------------------
```

# 进程

## **什么是进程**

进程是一个在系统中运行的程序

进程是已启动的可执行程序的运行实例，进程有以下组成部分:

- 已分配内存的地址空间

- 安全属性，包括所有权凭据和特权

- 进程代码的一个或多个执行线程

- 进程状态

程序：二进制文件，静态/bin/date，/usr/sbin/httpd，/usr/sbin/sshd，/usr/local/nginx/sbin/ngix

进程：是程序运行的过程，动态，有生命周期及运行状态

## 进程与线程

Python：

[面试必考 | 进程和线程的区别 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/114453309)

博客园：

[进程与线程 - 浅浅念 - 博客园 (cnblogs.com)](https://www.cnblogs.com/qianqiannian/p/7010909.html)

- 进程：

是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。

- 线程：

是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。

## **进程类型**

[(11条消息) Linux系统进程类型有哪些？进程状态有哪几种？常见的进程有哪些？_魏波-CSDN博客_linux系统进程类型](https://blog.csdn.net/weibo1230123/article/details/82187572)

守护进程：在系统引导过程中启动的进程，跟终端无关的进程

前台进程：跟终端相关，通过终端启动的进程

## **进程的生命周期**

![image-20220113201916117](C:\云计算笔记\云计算笔记.assets\image-20220113201916117.png)

fork源码：

[Linux如何创建一个新进程 - 秦时明月0515 - 博客园 (cnblogs.com)](https://www.cnblogs.com/zhangchao0515/p/5339964.html)

父进程复制自己的地址空间(fork)创建一个新的(子)进程结构。每个新进程分配一个唯一的进程ID(PID)，满足跟踪安全性之需。PID和父进程ID(PPID)是子进程环境的元素，任何进程都可以创建子进程，所有进程都是第一个系统进程的后代:

centos5/6：init

centos7： systemd



进程状态

子进程继承父进程的安全性身份、过去和当前的文件描述符、端口和资源特权、环境变量，以及程序代码。随后，子进程可能exec自己的程序代码。通常，父进程在子进程运行期间处于睡眠(sleeping)状态。当子进程完成时发出(exit)信息请求，在退出时，子进程已经关闭或丢弃了其资源环境，剩余的部分称之为僵尸(zombie)。父进程在子进程退出时收到信号而被唤醒，清理剩余的结构，然后继续执行其自己的程序代码。

## **进程状态**

在多任务处理操作系统中，每个CPU(或核心)在一个时间点上只能处理一个进程。在进程运行时，它对CPU时间和资源分配的要求会不断变化，从而为进程分配一个状态，它随着环境要求而改变。

R运行状态(runing): 表明进程要么在运行中要么在运行队列里，并不意味着进程一定在运行中。

S睡眠状态（sleeping）：意味着进程在等待事件的完成（这里的睡眠有时候也叫做可中断睡眠）

D磁盘睡眠状态(Disk sleep): 有时候也叫做不可中断睡眠，在这个状态的进程通常会等待IO的结束

T停止状态（stopped）：可以通过发送SIGSTOP信号给进程来停止(T)进程。这个被暂停的进程可以通过发送SIGCNT信号让进程继续运行。

Z僵尸状态(zombie)：通知父进程回收所有的资源

X死亡状态（dead）：这个状态只是一个返回状态，你不会在任务列表里看到这个状态。

- 僵尸进程：当一个进程fork一个子进程之后，如果子进程退出，而父进程没有利用wait 或者waitpid 来获取子进程的状态信息，那么子进程的状态描述符依然保存在系统中。

- 孤儿进程：当一个父进程fork一个子进程之后，父进程突然被终止了，那么这个子进程就成为了一个孤儿进程，它会被init进程接管

[(11条消息) 僵尸进程与孤儿进程解析_TerryZjl的博客-CSDN博客_僵尸进程和孤儿进程的区别](https://blog.csdn.net/dream_1996/article/details/71001006)

# 查看进程

## **ps命令**

静态查看进程ps 注: ps -aux 不同于 ps aux

> 常用组合：aux 
>
> u：以用户为中心组织进程状态信息显示 
>
> a：与终端相关的进程； 
>
> x：与终端无关的进程； 
>
> ~]# ps -uax 
>
> USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 
>
> 用户 进程ID CPU占用 内存占用 
>
> VSZ：Virtual memory SiZe 虚拟内存集 
>
> RSS：ReSident Size 常驻内存集———其他的都可以放入交换内存中 
>
> STAT：进程状态 
>
> R：running 
>
> S：interruptable sleeping 
>
> D：uninterruptable sleeping 
>
> T：stopped 
>
> Z：zombie 
>
> ​			+：前台进程 
>
> ​			l：多线程进程 
>
> ​			N：低优先级进程 
>
> ​			<：高优先级进程 
>
> ​			s：session leader 
>
> START：启动时间 
>
> TIME：运行占据cpu的累积时长 
>
> COMMAND：由哪个命令来启动的相关进程 
>
> 常用组合：ps -ef 
>
> -e：显示所有进程 
>
> -f：显示完整格式程序信息 
>
> 常用组合：ps -eFH 
>
> -F：显示完成格式的进程信息 
>
> -H：以进程层级格式显示进程相关信息 
>
> 常用组合：eo，axo 
>
> 自定义想要查询的字段值 
>
> -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm 
>
> -axo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wcha n:14,comm 
>
> ni：nice值 
>
> pri：priority，优先级 
>
> psr：processor，CPU 
>
> rtprio：实时优先级 

```bash
[root@server1 ~]# ps aux |less
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root          1  0.0  0.6 128152  6708 ?        Ss   10:11   0:02 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2  0.0  0.0      0     0 ?        S    10:11   0:00 [kthreadd]
root          3  0.0  0.0      0     0 ?        S    10:11   0:00 [ksoftirqd/0]
root          5  0.0  0.0      0     0 ?        S<   10:11   0:00 [kworker/0:0H]
root          6  0.0  0.0      0     0 ?        S    10:11   0:00 [kworker/u256:0]
root          7  0.0  0.0      0     0 ?        S    10:11   0:00 [migration/0]
root          8  0.0  0.0      0     0 ?        S    10:11   0:00 [rcu_bh]
root          9  0.0  0.0      0     0 ?        R    10:11   0:01 [rcu_sched]
root         10  0.0  0.0      0     0 ?        S<   10:11   0:00 [lru-add-drain]
root         11  0.0  0.0      0     0 ?        S    10:11   0:00 [watchdog/0]
root         13  0.0  0.0      0     0 ?        S    10:11   0:00 [kdevtmpfs]
root         14  0.0  0.0      0     0 ?        S<   10:11   0:00 [netns]
root         15  0.0  0.0      0     0 ?        S    10:11   0:00 [khungtaskd]
root         16  0.0  0.0      0     0 ?        S<   10:11   0:00 [writeback]
root         17  0.0  0.0      0     0 ?        S<   10:11   0:00 [kintegrityd]
root         18  0.0  0.0      0     0 ?        S<   10:11   0:00 [bioset]
root         19  0.0  0.0      0     0 ?        S<   10:11   0:00 [bioset]
root         20  0.0  0.0      0     0 ?        S<   10:11   0:00 [bioset]
root         21  0.0  0.0      0     0 ?        S<   10:11   0:00 [kblockd]
root         22  0.0  0.0      0     0 ?        S<   10:11   0:00 [md]
root         23  0.0  0.0      0     0 ?        S<   10:11   0:00 [edac-poller]
root         24  0.0  0.0      0     0 ?        S<   10:11   0:00 [watchdogd]
root         30  0.0  0.0      0     0 ?        S    10:11   0:00 [kswapd0]
root         31  0.0  0.0      0     0 ?        SN   10:11   0:00 [ksmd]
```

USER 			运行进程的用户

PID 				进程ID

%CPU			 CPU占用率

%MEM			 内存占用率

VSZ 				占用虚拟内存

RSS 				占用实际内存 驻留内存

TTY 				程序运行的终端

STAT			 进程状态 			man ps(/STATE)

​			R 运行

​			S 可中断睡眠 Sleep

​			D 不可中断睡眠

​			T 停止的进程

​			Z 僵尸进程

​			X 死掉的进程



​			Ss s进程的领导者，父进程

​			S< <优先级较高的进程

​			SN N优先级较低的进程

​			R+ +表示是前台的进程组

​			Sl 以线程的方式运行

START 			进程的启动时间

TIME 				进程占用CPU的总时间

COMMAND		 进程文件，进程名

```bash
[root@xwz ~]# ps aux --sort %cpu |less # 按照CPU使用率排序 
[root@xwz ~]# ps aux --sort -%cpu |less 
[root@xwz ~]# ps aux --sort rss |less 
[root@xwz ~]# ps aux --sort -rss |less
[root@xwz ~]# yum -y install httpd 
[root@xwz ~]# systemctl start httpd 
[root@xwz ~]# ps auxf |grep httpd # 按照父子进程层级显示 
root 29276 0.0 0.0 112724 988 pts/1 S+ 14:25 0:00 \_ grep --color=auto httpd 
root 29267 0.2 0.2 230408 5192 ? Ss 14:24 0:00 /usr/sbin/httpd -DFOREGROUND 
apache 29268 0.0 0.1 232492 3160 ? S 14:25 0:00 \_ /usr/sbin/httpd -DFOREGROUND 
apache 29269 0.0 0.1 232492 3160 ? S 14:25 0:00 \_ /usr/sbin/httpd -DFOREGROUND 
apache 29270 0.0 0.1 232492 3160 ? S 14:25 0:00 \_ /usr/sbin/httpd -DFOREGROUND 
apache 29271 0.0 0.1 232492 3160 ? S 14:25 0:00 \_ /usr/sbin/httpd -DFOREGROUND 
apache 29272 0.0 0.1 232492 3160 ? S 14:25 0:00 \_ /usr/sbin/httpd -DFOREGROUND 
[root@xwz ~]# ps -ef # 精简显示
```

自定义显示字段

```bash
[root@server1 ~]# ps axo user,pid,ppid,%mem,%cpu,command --sort -%cpu |less
USER        PID   PPID %MEM %CPU COMMAND
root          1      0  0.6  0.0 /usr/lib/systemd/systemd --switched-root --system --deserialize 22
root          2      0  0.0  0.0 [kthreadd]
root          3      2  0.0  0.0 [ksoftirqd/0]
root          5      2  0.0  0.0 [kworker/0:0H]
root          6      2  0.0  0.0 [kworker/u256:0]
root          7      2  0.0  0.0 [migration/0]
root          8      2  0.0  0.0 [rcu_bh]
root          9      2  0.0  0.0 [rcu_sched]
root         10      2  0.0  0.0 [lru-add-drain]
root         11      2  0.0  0.0 [watchdog/0]
root         13      2  0.0  0.0 [kdevtmpfs]
root         14      2  0.0  0.0 [netns]
root         15      2  0.0  0.0 [khungtaskd]
root         16      2  0.0  0.0 [writeback]
root         17      2  0.0  0.0 [kintegrityd]
root         18      2  0.0  0.0 [bioset]
root         19      2  0.0  0.0 [bioset]
root         20      2  0.0  0.0 [bioset]
root         21      2  0.0  0.0 [kblockd]
root         22      2  0.0  0.0 [md]
root         23      2  0.0  0.0 [edac-poller]
root         24      2  0.0  0.0 [watchdogd]
root         30      2  0.0  0.0 [kswapd0]
root         31      2  0.0  0.0 [ksmd]
```

查看指定进程的PID

```bash
[root@server1 ~]# cat /run/sshd.pid
7105
[root@server1 ~]# ps aux |grep sshd
root       7105  0.0  0.4 112756  4356 ?        Ss   10:11   0:00 /usr/sbin/sshd -D
root       9872  0.0  0.5 158760  5580 ?        Ss   20:38   0:00 sshd: root@pts/0
root      10089  0.0  0.5 158760  5516 ?        Ss   21:22   0:00 sshd: u02 [priv]
u02       10093  0.0  0.2 158760  2324 ?        S    21:22   0:00 sshd: u02@pts/1
root      10615  0.0  0.0 112724   988 pts/0    R+   22:51   0:00 grep --color=auto sshd
[root@server1 ~]# pgrep -l sshd
7105 sshd
9872 sshd
10089 sshd
10093 sshd
[root@server1 ~]# pidof sshd
10093 10089 9872 7105
```

查看进程树

yum -y install psmisc

```bash
[root@server1 ~]# pstree
systemd─┬─NetworkManager─┬─dhclient
        │                └─2*[{NetworkManager}]
        ├─auditd───{auditd}
        ├─chronyd
        ├─crond
        ├─dbus-daemon───{dbus-daemon}
        ├─firewalld───{firewalld}
        ├─login───bash
        ├─lvmetad
        ├─master─┬─pickup
        │        └─qmgr
        ├─mysqld_safe───mysqld───18*[{mysqld}]
        ├─nginx───nginx
        ├─php-fpm───5*[php-fpm]
        ├─polkitd───6*[{polkitd}]
        ├─rsyslogd───2*[{rsyslogd}]
        ├─sshd─┬─sshd───bash───su───bash───su───bash───su───bash───su───bash───su───bash───s+
        │      └─sshd───sshd───bash
        ├─systemd-journal
        ├─systemd-logind
        ├─systemd-udevd
        └─tuned───4*[{tuned}]
```

## **top命令**

动态显示系统相关资源的管理器，有点类似于windows当中的任务管理器

```bash
[root@xwz ~]# top 
[root@xwz ~]# top -d 1 # 一秒钟刷新一次 
[root@xwz ~]# top -d 1 -p 6995 # 查看指定PID 
[root@xwz ~]# top -d 1 -p 6995,1 # 查看多个PID进程 
[root@xwz ~]# top -d 1 -u apache # 查看指定用户的进程 
[root@xwz ~]# top -d 1 -b -n 2 > top.txt # 将2次top信息写入到文件
```

![image-20220113204031146](C:\云计算笔记\云计算笔记.assets\image-20220113204031146.png)

第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。

第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。

第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。

第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。（buffer和cache之间的区别，cache是提高cpu**和内存之间的数据交换速度**，buffer是io设备和存储设备之间的缓冲区）

第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。



进程信息

h|? 帮助

M 按内存的使用排序

P 按CPU使用排序

N 以PID的大小排序

R 对排序进行反转

f 自定义显示字段

1 显示所有CPU的负载

k 输入信号

< 向前

\> 向后

z 彩色

W 保存top环境设置 ~/.toprc

# 使用信号控制进程

给进程发送信号

列出所有支持的信号：

```bash
[root@server1 ~]# kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
```

**常用**

![image-20220113204252877](C:\云计算笔记\云计算笔记.assets\image-20220113204252877.png)

案例1,信号测试1和15

```bash
[root@server1 ~]# ps aux |grep crond
root       6172  0.0  0.1 126284  1692 ?        Ss   10:11   0:00 /usr/sbin/crond -n
root      10656  0.0  0.0 112724   984 pts/0    R+   22:59   0:00 grep --color=auto crond
[root@server1 ~]# kill -1 6172
[root@server1 ~]# ps aux |grep crond
root       6172  0.0  0.1 126284  1692 ?        Ss   10:11   0:00 /usr/sbin/crond -n
root      10658  0.0  0.0 112724   988 pts/0    R+   23:00   0:00 grep --color=auto crond
[root@server1 ~]# kill 7004
-bash: kill: (7004) - 没有那个进程
[root@server1 ~]# kill 6172
[root@server1 ~]# ps aux |grep crond
root      10673  0.0  0.0 112724   988 pts/0    R+   23:01   0:00 grep --color=auto crond
```

案例2,信号测试9,15

```bash
[root@xwz ~]# touch file1 file2 
[root@xwz ~]# tty 
/dev/pts/1 
[root@xwz ~]# vim file1 

[root@xwz ~]# tty 
/dev/pts/2 
[root@xwz ~]# vim file2 

[root@xwz ~]# ps aux |grep vim 
root 32072 0.2 0.2 151532 5064 pts/1 S+ 19:09 0:00 vim file1 
root 32127 0.1 0.2 151532 5080 pts/2 S+ 19:09 0:00 vim file2 
root 32176 0.0 0.0 112728 988 pts/3 S+ 19:09 0:00 grep -- color=auto vim 
[root@xwz ~]# kill 32072 
[root@xwz ~]# kill -9 32127 
[root@xwz ~]# killall vim # 杀死所有vim进程
```

案例4,踢出远程登录用户

```bash
[root@server1 ~]# w
 23:11:01 up 12:59,  3 users,  load average: 0.02, 0.03, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1                      10:11    2:21m  0.02s  0.02s -bash
root     pts/0    192.168.225.1    20:38    5.00s  0.09s  0.00s w
u02      pts/1    192.168.225.1    21:22    1:48m  0.00s  0.00s -bash
[root@server1 ~]# pkill -u u02
[root@server1 ~]# pkill -t pts/2 # 终止pts/2上所有进程
[root@server1 ~]# w
 23:12:21 up 13:01,  2 users,  load average: 0.00, 0.02, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     tty1                      10:11    2:22m  0.02s  0.02s -bash
root     pts/0    192.168.225.1    20:38    5.00s  0.10s  0.00s w
[root@server1 ~]# pkill -9 -t pts/2 # 终止pts/2上所有进程，并结束pts/2
```

# **进程优先级** **nice**

Linux进程调度及多任务

相对优先级nice

查看进程的nice级别

启动具有不同nice级别的进程

更改现有进程的nice级别

## **Linux进程调度及多任务**

每个CPU(或CPU核心)在一个时间点上只能处理一个进程，通过时间片技术，Linux实际能够运行的进程(和线程数)可以超出实际可用的CPU及核心数量。Linux内核进程调度程序将多个进程在CPU核心上快速切换，从而给用户多个进程在同时运行的假象。

## **相对优先级nice**

由于不是每个进程都与其他进程同样重要，可告知进程调度程序为不同的进程使用不同的调度策略。常规系统上运行的大多数进程所使用的的调度策略为SCHED_OTHER(也称为SCHED_NORMAL),但还有其他一些调度策略用于不同的目的。SCHED_OTHER调度策略运行的进程的相对优先级称为进程的nice值，可以有40种不同级别的nice值。

进程优先级 0-99：实时优先级，数字越小，优先级越低 1

00-139：静态优先级，数字越小，优先级越高

Nice值：-20，19

进程默认启动时nice为0，优先级为120

![image-20220113205903359](C:\云计算笔记\云计算笔记.assets\image-20220113205903359.png)

nice值越高表示优先级越低，例如+19，该进程容易将CPU使用量让给其他进程。

nice值越低表示优先级越高，例如-20，该进程更倾向于不让出CPU

## **查看进程的nice级别**

1，使用top查看nice级别

NI:实际nice级别

PR:将nice级别显示为映射到更大优先级队列，-20映射到0，+19映射到39

2,使用ps查看nice级别

```bash
[root@localhost ~]# ps axo pid,command,nice --sort=nice 
[root@localhost ~]# ps axo pid,command,nice,cls --sort=-nice
```

TS表示该进程使用的调度策略为SCHED_OTHER

## **启动具有不同nice级别的进程**

启动进程的时候为进程指定nice值

启动进程时，通常会继承父进程的nice级别，默认为0

```bash
[root@localhost ~]# nice -n -5 sleep 6000 & 
[root@localhost ~]# ps axo command,pid,nice |grep sleep 
[root@localhost ~]# nice -n -20 systemctl start httpd [root@localhost ~]# ps axo pid,command,nice,cls |grep httpd 
10146 /usr/sbin/httpd -DFOREGROUN 0 TS 
10161 /usr/sbin/httpd -DFOREGROUN 0 TS 
10162 /usr/sbin/httpd -DFOREGROUN 0 TS 
10163 /usr/sbin/httpd -DFOREGROUN 0 TS 
10164 /usr/sbin/httpd -DFOREGROUN 0 TS 
10165 /usr/sbin/httpd -DFOREGROUN 0 TS 
10167 grep --color=auto httpd     0 TS
```

## **更改现有进程的nice级别**

更改正在运行的进程的nice值 

1，使用top更改nice级别

r 调整进程的优先级(Nice Level) （-20高) - - - 0 - - - (19低) 

2，使用shell更改nice级别

```bash
[root@localhost ~]# sleep 7000 & [2] 10267 
[root@localhost ~]# renice -20 10267 10267 (进程 ID) 旧优先级为 0，新优先级为 -20
```

# 作业控制 jobs

- 将任务进行前台后台的切换

- 可以控制进程运行或者停止

作业控制是一个命令行功能，允许一个shell实例来运行和管理多个命令

如果没有作业控制，父进程fork()一个子进程后，将sleeping，直到子进程退出

使用作业控制，可以选择性暂停，恢复，以及异步运行命令，让shell可以在子进程运行期间返回接受其他命令

![image-20220114185423179](C:\云计算笔记\云计算笔记.assets\image-20220114185423179.png)

## fg 与 bg

**foreground** ：前台进程是在终端中运行的命令，该终端为进程的控制终端 。前台进程接受键盘产生的输入和信号,并允许从终端读取或写入到终端。

**background** ：后台进程没有控制终端 ，它不需要终端的交互。

- 可以**通过&将命令丢到后台**中进行运行
- 可以**通过jobs查看**任务
- 可以**通过 fg %1将任务1拿到前台**运行
- 可以**通过 bg %1将后台任务1唤醒**
- **jobs kill %1 结束后台任务1**

```bash
[root@server1 ~]# sleep 3000 &	# 运行程序(时)，让其在后台执行
[1] 8376
[root@server1 ~]# sleep 4000
^Z
[2]+  已停止               sleep 4000    # ^Z,将前台的程序挂起(暂停)到后台
[root@server1 ~]# sleep 4000

^Z
[3]+  已停止               sleep 4000
[root@server1 ~]# ps aux |grep sleep
root       8376  0.0  0.0 107952   620 pts/1    S    18:52   0:00 sleep 3000
root       8378  0.0  0.0 107952   616 pts/1    T    18:53   0:00 sleep 4000
root       8379  0.0  0.0 107952   620 pts/1    T    18:53   0:00 sleep 4000
root       8381  0.0  0.0 112724   988 pts/1    R+   18:53   0:00 grep --color=auto sleep
[root@server1 ~]# bg %2 # 让作业2在后台运行
[2]- sleep 4000 &
[root@server1 ~]# jobs	# 查看后台作业
[1]   运行中               sleep 3000 &
[2]-  运行中               sleep 4000 &
[3]+  已停止               sleep 4000
[root@server1 ~]# fg %1 # 将作业1调回到前台
sleep 3000
^Z
[1]+  已停止               sleep 3000
[root@server1 ~]# kill %1 # 终止作业1

[1]+  已停止               sleep 3000
[root@server1 ~]# jobs
[1]+  已终止               sleep 3000
[2]   运行中               sleep 4000 &
[3]-  已停止               sleep 4000


[root@server1 ~]# (while :; do date; sleep 2;done) &	# 输出在前台
[4] 8383
[root@server1 ~]# 2022年 01月 14日 星期五 18:54:56 CST
2022年 01月 14日 星期五 18:54:58 CST
2022年 01月 14日 星期五 18:55:00 CST
2022年 01月 14日 星期五 18:55:02 CST
2022年 01月 14日 星期五 18:55:05 CST
2022年 01月 14日 星期五 18:55:07 CST

[root@server1 ~]# (while :; do date; sleep 2;done) &>/dev/null &
[1] 8581		# 无输出内容
```

## **管理远程主机**

- **yum install -y screen** 安装终端
- **screen -s** 可以另外开启一个终端
- **ctrl+a+d **可以离开终端
- **screen -list** 可以查看终端列表
- **screen -r** 可以连接终端

```bash
[root@xwz ~]# yum install -y screen	#安装
# 开启一个新的终端 
[root@xwz ~]# screen 
# 开启一个新的终端并指定名称 
[root@xwz ~]# screen -S 'test1' 

# 离开终端 
# ctrl+a+d 
# 列出所有终端列表 
[root@server1 ~]# screen -list # 连接上指定的终端 
[root@server1 ~]# screen -r [ID]
```

# 存储基本知识

## **硬盘设备命名**

> 物理硬盘： /dev/sd[a-z]
>
> KVM虚拟化：
>
> ​				/dev/vd[a-z] 
>
> ​				/dev/sd[a-z]
>
> 设备命名
>
> IDE：/dev/hd
>
> SCSI,SATA,SAS,USB：/dev/sd
>
> 不同设备：a‐z
>
> 同一设备上的不同分区：1,2...
>
> /dev/sda1, /dev/sda2, /dev/sdb1

## **分区方式区别**

- MBR 	<2TB 	fdisk 	4个主分区，扩展分区，逻辑分区

  MBR: 使用32位表示扇区数，分区不超过2T ，按柱面进行分区，4个主分区；3主分区+1扩展(N个逻辑分区)。

- GPT     >2TB     gdisk     128个分区

​	GPT:支持128个分区，使用64位，使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区 表自动备份在头和尾两份

注意：从MBR转到GPT，或从GPT转换到MBR会导致数据全部丢失

![image-20220114191107910](C:\云计算笔记\云计算笔记.assets\image-20220114191107910.png)

# 存储结构与磁盘划分

Linux系统中常见的目录名称以及相应内容

![image-20220114191441495](C:\云计算笔记\云计算笔记.assets\image-20220114191441495.png)

表示路径的方式：

- 绝对路径指的是从根目录（/）开始写起的文件或目录名称

- 相对路径则指的是相对于当前路径的写法

## **物理设备的命名规则**

常见的硬件设备及其文件名称

![image-20220114191544485](C:\云计算笔记\云计算笔记.assets\image-20220114191544485.png)

一般的硬盘设备都会是以“/dev/sd”开头，分区编号按照如下规则：

- 主分区或扩展分区的编号从1开始，到4结束；

- 逻辑分区从编号5开始。

## 设备文件名称

> /dev/sda5
>
> 按序：
>
> 硬件设备文件所在目录
>
> hd表示IDE设备
>
> sd表示SCSI设备
>
> 硬盘的顺序号，以字母a,b,c......表示
>
> 分区的顺序号，以数字1,2,3......表示

## **文件系统与数据资料**

文件系统的作用是合理规划硬盘，以保证用户正常的使用需求。Linux系统支持数十种的文件系统，而最常见的文件系统如下所示。

![image-20220114192201265](C:\云计算笔记\云计算笔记.assets\image-20220114192201265.png)

格式化后会发生如下事情:

- Linux创建一个硬盘地图'superblock'，记录filesystem 的整体信息，包括inode/block的总量、使用量、剩余量， 以及文件系统的格式与相关信息等；
- inode：记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block 号码，默认一个inode表格128字节，一个block记录消耗4B，记录满了后会新建inode用于扩展。
  - 该文件的访问权限（read、write、execute）；
  - 该文件的所有者与所属组（owner、group）；
  - 该文件的大小（size）；
  - 该文件的创建或内容修改时间（ctime）；
  - 该文件的最后一次访问时间（atime）；
  - 该文件的修改时间（mtime）；
  - 文件的特殊权限（SUID、SGID、SBIT）；
  - 该文件的真实数据地址（point）。
- block：用于存储数据

![image-20220114192420177](C:\云计算笔记\云计算笔记.assets\image-20220114192420177.png)

计算机系统在发展过程中产生了众多的文件系统，为了使用户在读取或写入文件时不用关心底层的硬盘结构，Linux内核中的软件层为用户程序提供了一个VFS（Virtual File System，虚拟文件系统）接口，这样用户实际上在操作文件时就是统一对这个虚拟文件系统进行操作了。

![image-20220114192517462](C:\云计算笔记\云计算笔记.assets\image-20220114192517462.png)

## **挂载硬件设备**

### **mount**

mount  文件系统  挂载目录

可以挂载文件系统，但是这种方式临时生效，永久生效必须写入/etc/fstab
	mount -t: 指定文件类型
	mount -a：将/etc/fstab文件里的内容全部挂载

**mount命令中的参数以及作用**

![image-20220114192640154](C:\云计算笔记\云计算笔记.assets\image-20220114192640154.png)

如果想让硬件设备和目录永久地进行自动关联，就必须把挂载信息按照指定的填写格式“设备文件 挂载目录 格式类型 权限选项 是否备份 是否自检”,写入到/etc/fstab文件中。

![image-20220114193339484](C:\云计算笔记\云计算笔记.assets\image-20220114193339484.png)

**用于挂载信息的指定填写格式中，各字段所表示的意义**

![image-20220114192751035](C:\云计算笔记\云计算笔记.assets\image-20220114192751035.png)

### umount

撤销已经挂载的设备文件 

umount  [挂载点/设备文件]

## **添加硬盘设备**

### **fdisk**

管理磁盘分区

fdisk  [磁盘名称]

**fdisk命令中的参数以及作用**

![image-20220114192924282](C:\云计算笔记\云计算笔记.assets\image-20220114192924282.png)

### df 命令

查看某一个文件系统的挂载及使用情况
	-T：列出文件系统
	-h：展示单位

### du 命令

查看文件数据占用量

du  [选项]  [文件] 

```bash
[root@server1 ~]# du
[root@server1 ~]# du -sh /*
```

### **dd 命令**

dd if=/dev/zero of=file bs=10M count=10
	从吐零机想file1中输入内容，这个工具可以帮助我们生成想要固定大小的文件

## **添加交换分区**

SWAP（交换）分区是一种通过在硬盘中预先划分一定的空间，然后将把内存中暂时不常用的数据临时存放到硬盘中，以便腾出物理内存空间让更活跃的程序服务来使用的技术在生产环境中，交换分区的大小一般为真实物理内存的1.5～2倍.

```bash
[root@server1 ~]# umount /dev/sdb
[root@server1 ~]# mkswap /dev/sdb
mkswap: /dev/sdb: warning: wiping old ext4 signature.
正在设置交换空间版本 1，大小 = 10485756 KiB
无标签，UUID=11f71300-2bdd-41a6-aadb-1d45ecbb43b6
[root@server1 ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           972M        209M        452M         25M        310M        510M
Swap:          2.0G          0B        2.0G
[root@server1 ~]# swapon /dev/sdb
[root@server1 ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           972M        217M        444M         25M        310M        502M
Swap:           11G          0B         11G
[root@server1 ~]# vim /etc/fstab
#
# /etc/fstab
# Created by anaconda on Sat Oct 30 12:06:36 2021
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=21949952-ac4a-4f32-a3cb-414bb5a679d0 /boot                   xfs     defaults        0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0
/dev/sdb /gua                                   ext4    defaults        0 0 
/dev/sdb                                        swap    swap            0 0
[root@server1 ~]# free -h
              total        used        free      shared  buff/cache   available
Mem:           972M        217M        444M         25M        310M        502M
Swap:           11G          0B         11G
```

## **磁盘容量配额**

### **案例描述**

- 创建5个用户user1,user2,user3,user4,user5，密码和用户名相同，初始组为usergrp组。

- 5个用户都可以取得300M的磁盘使用空间，文件数量不限。超过250M,给于提示。

- usergrp这个组内成员最大使用空间1GB。

- 如果有用户超过soft限制，给14天的宽限时间。

### **准备磁盘**

- 创建分区

```bash
[root@server1 ~]# fdisk /dev/sdb
欢迎使用 fdisk (util-linux 2.23.2)。

更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

Device does not contain a recognized partition table
使用磁盘标识符 0xc1b8cab4 创建新的 DOS 磁盘标签。

命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): p
分区号 (1-4，默认 1)：
起始 扇区 (2048-41943039，默认为 2048)：
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-41943039，默认为 41943039)：+2G
分区 1 已设置为 Linux 类型，大小设为 2 GiB

命令(输入 m 获取帮助)：w
The partition table has been altered!

Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@server1 ~]# partprobe
Warning: 无法以读写方式打开 /dev/sr0 (只读文件系统)。/dev/sr0 已按照只读方式打开。
[root@server1 ~]# lsblk
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   19G  0 part 
  ├─centos-root 253:0    0   17G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0   20G  0 disk 
└─sdb1            8:17   0    2G  0 part 
sdc               8:32   0   20G  0 disk 
sr0              11:0    1  918M  0 rom  
```

- 格式化文件系统

![image-20220114194751635](C:\云计算笔记\云计算笔记.assets\image-20220114194751635.png)

- 创建目录并挂载

![image-20220114194847007](C:\云计算笔记\云计算笔记.assets\image-20220114194847007.png)

### 准备用户

![image-20220114194933646](C:\云计算笔记\云计算笔记.assets\image-20220114194933646.png)

### **确保文件系统支持**

- 检查挂载点是否支持quota配置

```bash
[root@server ~]# mount | grep mountpoint1 
/dev/sdb1 on /mnt/mountpoint1 type ext4 (rw,relatime,data=ordered)
```

- 重新挂载，让文件系统支持quota配置

```bash
[root@server ~]# mount -o remount,usrquota,grpquota /mnt/mountpoint1/ 
[root@server ~]# mount | grep mountpoint1 
/dev/sdb1 on /mnt/mountpoint1 type ext4 (rw,relatime,quota,usrquota,grpquota,data=ordered)
```

- 确保开机自动支持quota配置

```bash
[root@server ~]# tail -n 1 /etc/mtab >> /etc/fstab
```

### **安装quota**

\# **yum install quota -y** 

**quotacheck主要参数**

- -a：扫描所有在/etc/mtab内含有quota参数的文件系统

- -u：针对用户扫描文件与目录的使用情况，会新建一个aquota.user文件

- -g：针对用户组扫描文件与目录的使用情况，会新增一个aquota.group文件

- -v：显示扫描过程的信息

### **开启quota**

```bash
[root@server mountpoint1]# quotacheck -avug 
[root@server mountpoint1]# quotaon -avug 
/dev/sdb1 [/mnt/mountpoint1]: group quotas turned on 
/dev/sdb1 [/mnt/mountpoint1]: user quotas turned on
```

### **编辑限额配置**

```bash
[root@server mountpoint1]# edquota -u user1
```

![image-20220114195419507](C:\云计算笔记\云计算笔记.assets\image-20220114195419507.png)

- 可以将针对user1的设置复制到user2

```bash
[root@server mountpoint1]# edquota -p user1 -u user2
```

- 修改宽限时间

```bash
[root@server mountpoint1]# edquota -t
```

- 查看限制情况

![image-20220114195605067](C:\云计算笔记\云计算笔记.assets\image-20220114195605067.png)

### **测试**

```bash
[user1@server ~]$ dd if=/dev/zero of=bigfile bs=10M count=50 
sdb1: warning, user block quota exceeded. 
sdb1: write failed, user block limit reached. 
dd: 写入"bigfile" 出错: 超出磁盘限额 
记录了30+0 的读入 
记录了29+0 的写出 
307183616字节(307 MB)已复制，1.96853 秒，156 MB/秒 
[user1@server ~]$ du -sh * 
293M bigfile
```

[quota - linux磁盘配额管理 - stardsd - 博客园 (cnblogs.com)](https://www.cnblogs.com/sddai/p/11111895.html)

Linux quota命令用于显示磁盘已使用的空间与限制。

执行quota指令，可查询磁盘空间的限制，并得知已使用多少空间。

**参数说明**：

- -g 列出群组的磁盘空间限制。

- -q 简明列表，只列出超过限制的部分。

- -u 列出用户的磁盘空间限制。

- -v 显示该用户或群组，在所有挂入系统的存储设备的空间限制。

- -V 显示版本信息。

quota命令还有软限制和硬限制的功能

- 软限制：当达到软限制时会提示用户，但仍允许用户在限定的额度内继续使用。
- 硬限制：当达到硬限制时会提示用户，且强制终止用户的操作。

# **软硬方式链接**

在Linux系统中存在硬链接和软连接两种文件。

- 硬链接（hard link）：

可以将它理解为一个“指向原始文件inode的指针”，系统不为它分配独立的inode和文件。所以，硬链接文件与原始文件其实是同一个文件，只是名字不同。我们每添加一个硬链接，该文件的inode连接数就会增加1；而且只有当该文件的inode连接数为0时，才算彻底将它删除。换言之，由于硬链接实际上是指向原文件inode的指针，因此即便原始文件被删除，依然可以通过硬链接文件来访问。需要注意的是，由于技术的局限性，我们不能跨分区对目录文件进行链接。

![image-20220114195945245](C:\云计算笔记\云计算笔记.assets\image-20220114195945245.png)

- 软链接（也称为符号链接[symbolic link]）：

仅仅包含所链接文件的路径名，因此能链接目录文件，也可以跨越文件系统进行链接。但是，当原始文件被删除后，链接文件也将失效，从这一点上来说与Windows系统中的“快捷方式”具有一样的性质。

![image-20220114200011808](C:\云计算笔记\云计算笔记.assets\image-20220114200011808.png)

**硬链接特点**

- 不论是修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改 变。

- 不论是删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件都可以被访问。

- 硬链接不会建立新的 inode 信息，也不会更改 inode 的总数。

- 硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的硬链接不能连接目录

**软链接特点**

- 不论是修改源文件（check），还是修改软链接文件（check-soft)，另一个文件中的数据都会发生改变。

- 删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在。

- 软链接会新建自己的 inode 信息和 block，只是在 block 中不存储实际文件数据，而存储的是源文件的文件 名及 inode 号。

- 软链接可以链接目录。 软链接可以跨分区

**总结：**

软链接文件
	文件类型为l，链接文件
	ln -s 源文件 软链接文件，建议源文件的路径使用绝对路径的形式，否则可能会出问题
	当源文件或者软链接文件有一个被修改时另一个也会被修改
	当源文件删除文件时，软链接文件失效，当软链接文件被删除时源文件没有任何影响
	软链接文件会单独建立inode和block，与源文件的inode是不一样的
	软链接文件可以跨分区
	
硬链接文件
	文件类型为普通文件
	ln 源文件 硬链接文件
	当源文件或者链接文件有一个被修改时另一个也会被修改
	每增加一个硬链接文件，文件的链接数都会加1，删除任意一个文件只要链接数不为0都可以正常使用
	硬链接的文件的inode编号和源文件是相同的，不会单独分配inode和block
	硬链接文件不可以跨分区

## **ln**

用于创建链接文件

ln  [选项]  目标

**ln命令中可用的参数以及作用**

![image-20220114200240220](C:\云计算笔记\云计算笔记.assets\image-20220114200240220.png)

- 软链接演示

```bash
[root@server1 ~]# echo "hello1" > test
[root@server1 ~]# ln -s test test11
[root@server1 ~]# cat test11
hello1
[root@server1 ~]# ls -l test
-rw-r--r--. 1 root root 7 1月  14 20:03 test
[root@server1 ~]# rm -f test
[root@server1 ~]# cat test11
cat: test11: 没有那个文件或目录
```

- 硬链接演示

```bash
[root@server1 ~]# echo "hello2" > test
[root@server1 ~]# ln test test22
[root@server1 ~]# cat test22
hello2
[root@server1 ~]# rm -f test
[root@server1 ~]# cat test22
hello2
```

# **RAID（独立冗余磁盘阵列）**

## **常见raid级别**

### **RAID 0**

如果说需要存储的数据是12345678，那么可能是1357存储在disk1上面，2468存储在disk2上面

- 读取速率得到一定提高

- 没有数据冗余性

- 最少需要两块硬盘组合

- 有效存储空间为N块盘

![image-20220114200723024](C:\云计算笔记\云计算笔记.assets\image-20220114200723024.png)

### **RAID 1**

如果需要存储1357四份数据，那么会将同样的数据备份写入不同的盘中

- 读写速率没有得到提升

- 具有数据冗余性

- 最少需要两块磁盘

- 有效存储空间为N/2块磁盘

![image-20220114200755841](C:\云计算笔记\云计算笔记.assets\image-20220114200755841.png)

### **RAID 5**

- 具有数据安全性

- 可以提高读写性能

- 最少需要三块盘

- 有效存储空间为N-1块磁盘

![image-20220114200827101](C:\云计算笔记\云计算笔记.assets\image-20220114200827101.png)

### **RAID 10**

- 具有数据冗余性

- 提高数据读写速率

- 有效存储空间为N/2块磁盘

![image-20220114200909089](C:\云计算笔记\云计算笔记.assets\image-20220114200909089.png)

### **RAID 01**

- 具有数据冗余性

- 提高数据读写速率

- 有效存储空间为N/2块磁盘

![image-20220114200935104](C:\云计算笔记\云计算笔记.assets\image-20220114200935104.png)

## **案例-组建raid10阵列**

- 添加四块磁盘

- 使用mdadm命令创建软件磁盘阵列

**mdadm命令的常用参数以及作用**

![image-20220114201032565](C:\云计算笔记\云计算笔记.assets\image-20220114201032565.png)

```bash
[root@localhost ~]# mdadm -Cv /dev/md0 -a yes -n 4 -l 10 /dev/sdb /dev/sdc /dev/sdd /dev/sde

#把制作好的RAID磁盘阵列格式化为ext4格式
[root@localhost ~]# mkfs.ext4 /dev/md0

#创建挂载点然后把硬盘设备进行挂载操作
[root@localhost ~]# mkdir /RAID 
[root@localhost ~]# mount /dev/md0 /RAID/ 
[root@localhost ~]# df -h
#/dev/md0 40G 49M 38G 1% /RAID

#查看/dev/md0磁盘阵列的详细信息，并把挂载信息写入到配置文件中，使其永久生效。
[root@localhost ~]# mdadm -D /dev/md0
[root@localhost ~]# echo "/dev/md0 /RAID ext4 defaults 0 0" >> /etc/fstab
```

## **案例-损坏磁盘阵列及修复**

在确认有一块物理硬盘设备出现损坏而不能继续正常使用后，应该使用mdadm命令将其移除，然后查看RAID磁盘阵列的状态，可以发现状态已经改变。

```bash
[root@localhost ~]# mdadm /dev/md0 -f /dev/sdb 
#mdadm: set /dev/sdb faulty in /dev/md0 
[root@localhost ~]# mdadm -D /dev/md0
#0 8 16 - faulty /dev/sdb
```

在RAID 10级别的磁盘阵列中，当RAID 1磁盘阵列中存在一个故障盘时并不影响RAID 10磁盘阵列的使用。当购买了新的硬盘设备后再使用mdadm命令来予以替换即可，在此期间我们可以在/RAID目录中正常地创建或删除文件。由于我们是在虚拟机中模拟硬盘，所以先**重启系统**，然后再把新的硬盘添加到RAID磁盘阵列中。

```bash
[root@localhost ~]# umount /RAID/ 
[root@localhost ~]# mdadm /dev/md0 -a /dev/sdb 
mdadm: added /dev/sdb 
[root@localhost ~]# mdadm -D /dev/md0
Number Major Minor RaidDevice State 
4 8 16 0 spare rebuilding /dev/sdb 
1 8 32 1 active sync set-B /dev/sdc 
2 8 48 2 active sync set-A /dev/sdd 
3 8 64 3 active sync set-B /dev/sde
```

## **案例-磁盘阵列+备份盘**

为了避免多个实验之间相互发生冲突，我们需要保证每个实验的相对独立性，为此需要大家自行将虚拟机**还原到初始状态**。

部署RAID 5磁盘阵列时，至少需要用到3块硬盘，还需要再加一块备份硬盘，所以总计需要在虚拟机中模拟4块硬盘设备

现在创建一个RAID 5磁盘阵列+备份盘。在下面的命令中,参数-n 3代表创建这个RAID 5磁盘阵列所需的硬盘数，参数-l 5代表RAID的级别，而参数-x 1则代表有一块备份盘。当查看/dev/md0（即RAID 5磁盘阵列的名称）磁盘阵列的时候就能看到有一块备份盘在等待中了。

```bash
[root@localhost ~]# mdadm -Cv /dev/md0 -n 3 -l 5 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde
#Continue creating array? y
[root@localhost ~]# mdadm -D /dev/md0
Number Major Minor RaidDevice State 
0 8 16 0 active sync /dev/sdb 
1 8 32 1 active sync /dev/sdc 
4 8 48 2 active sync /dev/sdd 
3 8 64 - spare /dev/sde
```

将部署好的RAID 5磁盘阵列格式化为ext4文件格式，然后挂载到目录上，之后就可以使用了。

```bash
[root@localhost ~]# mkfs.ext4 /dev/md0
[root@localhost ~]# echo "/dev/md0 /RAID ext4 defaults 0 0" >> /etc/fstab 
```

把硬盘设备/dev/sdb移出磁盘阵列，然后迅速查看/dev/md0磁盘阵列的状态

```bash
[root@localhost ~]# mdadm /dev/md0 -f /dev/sdb 
mdadm: set /dev/sdb faulty in /dev/md0 
[root@localhost ~]# mdadm -D /dev/md0
Number Major Minor RaidDevice State 
3 8 64 0 spare rebuilding /dev/sde 
1 8 32 1 active sync /dev/sdc 
4 8 48 2 active sync /dev/sdd 

0 8 16 - faulty /dev/sdb
```

# **LVM（逻辑卷管理器）**

逻辑卷管理器是Linux系统用于对硬盘分区进行管理的一种机制，理论性较强，其创建初衷是为了解决硬盘设备在创建分区后不易修改分区大小的缺陷。尽管对传统的硬盘分区进行强制扩容或缩容从理论上来讲是可行的，但是却可能造成数据的丢失。而LVM技术是在硬盘分区和文件系统之间添加了一个逻辑层，它提供了一个抽象的卷组，可以把多块硬盘进行卷组合并。这样一来，用户不必关心物理硬盘设备的底层架构和布局，就可以实现对硬盘分区的动态调整。

![image-20220114202207522](C:\云计算笔记\云计算笔记.assets\image-20220114202207522.png)

物理卷处于LVM中的最底层，可以将其理解为物理硬盘、硬盘分区或者RAID磁盘阵列，这都可以。卷组建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。这就是LVM的核心理念。

相关名词概念如下:

- 物理卷：物理磁盘、分区或者磁盘阵列

- 卷组：建立在物理卷之上，一个卷组可以包含多个物理卷，而且在卷组创建之后也可以继续向其中添加新的物理卷。

- 逻辑卷：逻辑卷是用卷组中空闲的资源建立的，并且逻辑卷在建立后可以动态地扩展或缩小空间。

- PE：物理卷区域，物理卷组成的最小单位

- LE：逻辑区域，是逻辑卷组成的最小单位，大小通常是PE的整数倍

![image-20220114202256979](C:\云计算笔记\云计算笔记.assets\image-20220114202256979.png)

## **部署逻辑卷**

**常用的LVM部署命令**

![image-20220114202401863](C:\云计算笔记\云计算笔记.assets\image-20220114202401863.png)

**第1步：让新添加的两块硬盘设备支持LVM技术**

```bash
[root@localhost ~]# pvcreate /dev/sdb 
Physical volume "/dev/sdb" successfully created. 
[root@localhost ~]# pvcreate /dev/sdc 
Physical volume "/dev/sdc" successfully created.
```

**第2步：把两块硬盘设备加入到storage卷组中，然后查看卷组的状态**

```bash
[root@localhost ~]# vgcreate storage /dev/sdb /dev/sdc 
Volume group "storage" successfully created 
[root@localhost ~]# vgdisplay
```

**第3步：切割出一个约为150MB的逻辑卷设备。**

lvcreate -l一共有一下三种用法

- 第一种是取卷组空间的百分比
- 第二种是取卷组剩余空间的百分比
- 第三种是指定多少个LE数量
  	lvcreate -n v1 -l 50%VG storage
  	lvcreate -n v2 -l 60%FREE storage
  	lvcreate -n v3 -l 37 storage

这里需要注意切割单位的问题。在对逻辑卷进行切割时有两种计量单位。

- 第一种是以容量为单位，所使用的参数为-L。例如，使用-L 150M生成一个大小为150MB的逻辑卷。

- 另外一种是以基本单元的个数为单位，所使用的参数为-l。每个基本单元的大小默认为4MB。例如，使用-l 37可以生成一个大小为37×4MB=148MB的逻辑卷。

```bash
[root@localhost ~]# lvcreate -n vo -l 37 storage 
	Logical volume "vo" created. 
[root@localhost ~]# lvdisplay
```

**第4步：把生成好的逻辑卷进行格式化，然后挂载使用。**

```bash
[root@localhost ~]# mkfs.ext4 /dev/storage/vo
[root@localhost ~]# mkdir /vo 
[root@localhost ~]# mount /dev/storage/vo /vo 
[root@localhost ~]# df -h
/dev/mapper/storage-vo 140M 1.6M 128M 2% /vo
[root@localhost ~]# echo "/dev/storage/vo /vo ext4 defaults 0 0" >> /etc/fstab
```

## **扩容逻辑卷**

Linux e2fsck命令用于检查使用 Linux ext2 档案系统的 partition 是否正常工作

**第1步：把上一个实验中的逻辑卷vo扩展至290MB**

```bash
[root@localhost ~]# umount /vo 
[root@localhost ~]# lvextend -L 290M /dev/storage/vo
```

**第2步：检查硬盘完整性，并重置硬盘容量**

```bash
[root@localhost ~]# e2fsck -f /dev/storage/vo
[root@localhost ~]# resize2fs /dev/storage/vo
```

**第3步：重新挂载硬盘设备并查看挂载状态**

```bash
[root@localhost ~]# mount -a 
[root@localhost ~]# df -h
/dev/mapper/storage-vo 279M 2.1M 259M 1% /vo
```

## **缩小逻辑卷**

**第1步：检查文件系统的完整性**

```bash
[root@localhost ~]# umount /vo 
[root@localhost ~]# e2fsck -f /dev/storage/vo
```

**第2步：把逻辑卷vo的容量减小到120MB**

```bash
[root@localhost ~]# resize2fs /dev/storage/vo 120M
[root@localhost ~]# lvreduce -L 120M /dev/storage/vo
```

**第3步：重新挂载文件系统并查看系统状态**

```bash
[root@localhost ~]# mount -a 
[root@localhost ~]# df -h
```

在逻辑卷进行扩容或者缩容时如果使用的文件系统是xfs

使用下面的工具
	xfs类型的文件系统用：xfs_growfs /mnt/vo，后面接的是挂载点。 
	resize2fs /dev/storage/vo  后面接的是挂载点的路径

## **逻辑卷快照**

LVM还具备有“快照卷”功能，该功能类似于虚拟机软件的还原时间点功能。例如，可以对某一个逻辑卷设备做一次快照，如果日后发现数据被改错了，就可以利用之前做好的快照卷进行覆盖还原。LVM的快照卷功能有两个特点：

- 快照卷的容量必须等同于逻辑卷的容量；

- 快照卷仅一次有效，一旦执行还原操作后则会被立即自动删除。

```bash
[root@localhost ~]# vgdisplay
#接下来用重定向往逻辑卷设备所挂载的目录中写入一个文件
[root@localhost ~]# echo "hello world" > /vo/readme.txt 
[root@localhost ~]# ls -l /vo 
total 14 
drwx------. 2 root root 12288 Apr 18 13:38 lost+found 
-rw-r--r--. 1 root root 12 Apr 18 13:48 readme.txt
```

**第1步：使用-s参数生成一个快照卷，使用-L参数指定切割的大小。另外，还需要在命令后面写上是针对哪个逻辑卷执行的快照操作。**

```bash
[root@localhost ~]# lvcreate -L 120M -s -n SNAP /dev/storage/vo 
	Logical volume "SNAP" created. 
[root@localhost ~]# lvdisplay
#发现使用占用率小
```

**第2步：在逻辑卷所挂载的目录中创建一个100MB的垃圾文件，然后再查看快照卷的状态。可以发现存储空间占的用量上升了**

```bash
[root@localhost ~]# dd if=/dev/zero of=/vo/files count=1 bs=100M 
1+0 records in 
1+0 records out 
104857600 bytes (105 MB) copied, 3.29409 s, 31.8 MB/s 
[root@localhost ~]# lvdisplay
#发现使用占用率大
```

**第3步：为了校验SNAP快照卷的效果，需要对逻辑卷进行快照还原操作。在此之前记得先卸载掉逻辑卷设备与目录的挂载。**

```bash
[root@localhost ~]# umount /vo 
[root@localhost ~]# lvconvert --merge /dev/storage/SNAP
```

**第4步：快照卷会被自动删除掉，并且刚刚在逻辑卷设备被执行快照操作后再创建出来的100MB的垃圾文件也被清除了**

```bash
[root@localhost ~]# mount -a 
[root@localhost ~]# ls /vo/ 
lost+found readme.txt
```

## **删除逻辑卷**

**第1步：取消逻辑卷与目录的挂载关联，删除配置文件中永久生效的设备参数。**

```bash
[root@localhost ~]# umount /vo/ 
[root@localhost ~]# vi /etc/fstab
#删除
/dev/mapper/centos-swap swap swap defaults 0 0
```

**第2步：删除逻辑卷设备，需要输入y来确认操作**

```bash
[root@localhost ~]# lvremove /dev/storage/vo 
Do you really want to remove active logical volume storage/vo? [y/n]: y 
	Logical volume "vo" successfully removed
```

**第3步：删除卷组，此处只写卷组名称即可，不需要设备的绝对路径。**

```bash
[root@localhost ~]# vgremove storage 
	Volume group "storage" successfully removed
```

**第4步：删除物理卷设备**

```bash
[root@localhost ~]# pvremove /dev/sdb /dev/sdc 
	Labels on physical volume "/dev/sdb" successfully wiped. 
	Labels on physical volume "/dev/sdc" successfully wiped.
```

